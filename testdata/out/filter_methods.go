// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package out

import (
	"regexp"
	"time"
)

///////////////////////////////// CUSTOM  TYPES /////////////////////////////////

func (f *FilterTypeThree) Eval(obj *TypeThree) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle TypeThreeStringFieldFiltered field
	if f.TypeThreeStringFieldFiltered != nil && !f.TypeThreeStringFieldFiltered.Eval(&obj.TypeThreeStringFieldFiltered) {
		return false
	}

	// Handle TypeThreeNumberFieldFiltered field
	if f.TypeThreeNumberFieldFiltered != nil && !f.TypeThreeNumberFieldFiltered.Eval(&obj.TypeThreeNumberFieldFiltered) {
		return false
	}

	// Handle TypeThreeTimeFieldFiltered field
	if f.TypeThreeTimeFieldFiltered != nil && !f.TypeThreeTimeFieldFiltered.Eval(&obj.TypeThreeTimeFieldFiltered) {
		return false
	}

	// Handle TypeThreeBooleanFiltered field
	if f.TypeThreeBooleanFiltered != nil && !f.TypeThreeBooleanFiltered.Eval(&obj.TypeThreeBooleanFiltered) {
		return false
	}

	return true
}

func (f *NestedFilterTypeThree) Eval(obj *TypeThree) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle TypeThreeStringFieldFiltered field
	if f.TypeThreeStringFieldFiltered != nil && !f.TypeThreeStringFieldFiltered.Eval(&obj.TypeThreeStringFieldFiltered) {
		return false
	}

	// Handle TypeThreeNumberFieldFiltered field
	if f.TypeThreeNumberFieldFiltered != nil && !f.TypeThreeNumberFieldFiltered.Eval(&obj.TypeThreeNumberFieldFiltered) {
		return false
	}

	// Handle TypeThreeTimeFieldFiltered field
	if f.TypeThreeTimeFieldFiltered != nil && !f.TypeThreeTimeFieldFiltered.Eval(&obj.TypeThreeTimeFieldFiltered) {
		return false
	}

	// Handle TypeThreeBooleanFiltered field
	if f.TypeThreeBooleanFiltered != nil && !f.TypeThreeBooleanFiltered.Eval(&obj.TypeThreeBooleanFiltered) {
		return false
	}

	return true
}

func (f *NestedFilterTypeTwo) Eval(obj *TypeTwo) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle TypeTwoStringFieldFiltered field
	if f.TypeTwoStringFieldFiltered != nil && !f.TypeTwoStringFieldFiltered.Eval(&obj.TypeTwoStringFieldFiltered) {
		return false
	}

	// Handle TypeTwoNumberFieldFiltered field
	if f.TypeTwoNumberFieldFiltered != nil && !f.TypeTwoNumberFieldFiltered.Eval(&obj.TypeTwoNumberFieldFiltered) {
		return false
	}

	// Handle TypeTwoTimeFieldFiltered field
	if f.TypeTwoTimeFieldFiltered != nil && !f.TypeTwoTimeFieldFiltered.Eval(&obj.TypeTwoTimeFieldFiltered) {
		return false
	}

	// Handle TypeTwoBooleanFiltered field
	if f.TypeTwoBooleanFiltered != nil && !f.TypeTwoBooleanFiltered.Eval(&obj.TypeTwoBooleanFiltered) {
		return false
	}

	// Handle TypeTwoSliceWithTypeTwos slice
	if f.TypeTwoSliceWithTypeTwos != nil {
		for _, elem := range obj.TypeTwoSliceWithTypeTwos {
			if !f.TypeTwoSliceWithTypeTwos.Eval(elem) {
				return false
			}
		}
	}

	// Handle TypeTwoWithTypeThree field
	if f.TypeTwoWithTypeThree != nil && !f.TypeTwoWithTypeThree.Eval(obj.TypeTwoWithTypeThree) {
		return false
	}

	// Handle TypeTwoWithTypeThreeNotMandatory field
	if f.TypeTwoWithTypeThreeNotMandatory != nil && !f.TypeTwoWithTypeThreeNotMandatory.Eval(obj.TypeTwoWithTypeThreeNotMandatory) {
		return false
	}

	return true
}

func (f *FilterTypeTwo) Eval(obj *TypeTwo) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle TypeTwoStringFieldFiltered field
	if f.TypeTwoStringFieldFiltered != nil && !f.TypeTwoStringFieldFiltered.Eval(&obj.TypeTwoStringFieldFiltered) {
		return false
	}

	// Handle TypeTwoNumberFieldFiltered field
	if f.TypeTwoNumberFieldFiltered != nil && !f.TypeTwoNumberFieldFiltered.Eval(&obj.TypeTwoNumberFieldFiltered) {
		return false
	}

	// Handle TypeTwoTimeFieldFiltered field
	if f.TypeTwoTimeFieldFiltered != nil && !f.TypeTwoTimeFieldFiltered.Eval(&obj.TypeTwoTimeFieldFiltered) {
		return false
	}

	// Handle TypeTwoBooleanFiltered field
	if f.TypeTwoBooleanFiltered != nil && !f.TypeTwoBooleanFiltered.Eval(&obj.TypeTwoBooleanFiltered) {
		return false
	}

	// Handle TypeTwoSliceWithTypeTwos slice
	if f.TypeTwoSliceWithTypeTwos != nil {
		for _, elem := range obj.TypeTwoSliceWithTypeTwos {
			if !f.TypeTwoSliceWithTypeTwos.Eval(elem) {
				return false
			}
		}
	}

	// Handle TypeTwoWithTypeThree field
	if f.TypeTwoWithTypeThree != nil && !f.TypeTwoWithTypeThree.Eval(obj.TypeTwoWithTypeThree) {
		return false
	}

	// Handle TypeTwoWithTypeThreeNotMandatory field
	if f.TypeTwoWithTypeThreeNotMandatory != nil && !f.TypeTwoWithTypeThreeNotMandatory.Eval(obj.TypeTwoWithTypeThreeNotMandatory) {
		return false
	}

	return true
}

func (f *FilterTypeOne) Eval(obj *TypeOne) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle TypeOneStringFieldFiltered field
	if f.TypeOneStringFieldFiltered != nil && !f.TypeOneStringFieldFiltered.Eval(&obj.TypeOneStringFieldFiltered) {
		return false
	}

	// Handle TypeOneStringFieldFilteredNotMandatory field
	if f.TypeOneStringFieldFilteredNotMandatory != nil && !f.TypeOneStringFieldFilteredNotMandatory.Eval(obj.TypeOneStringFieldFilteredNotMandatory) {
		return false
	}

	// Handle TypeOneNumberFieldFiltered field
	if f.TypeOneNumberFieldFiltered != nil && !f.TypeOneNumberFieldFiltered.Eval(&obj.TypeOneNumberFieldFiltered) {
		return false
	}

	// Handle TypeOneNumberFieldFilteredNotMandatory field
	if f.TypeOneNumberFieldFilteredNotMandatory != nil && !f.TypeOneNumberFieldFilteredNotMandatory.Eval(obj.TypeOneNumberFieldFilteredNotMandatory) {
		return false
	}

	// Handle TypeOneTimeFieldFiltered field
	if f.TypeOneTimeFieldFiltered != nil && !f.TypeOneTimeFieldFiltered.Eval(&obj.TypeOneTimeFieldFiltered) {
		return false
	}

	// Handle TypeOneTimeFieldFilteredNotMandatory field
	if f.TypeOneTimeFieldFilteredNotMandatory != nil && !f.TypeOneTimeFieldFilteredNotMandatory.Eval(obj.TypeOneTimeFieldFilteredNotMandatory) {
		return false
	}

	// Handle TypeOneBooleanFiltered field
	if f.TypeOneBooleanFiltered != nil && !f.TypeOneBooleanFiltered.Eval(&obj.TypeOneBooleanFiltered) {
		return false
	}

	// Handle TypeOneBooleanFilteredNotMandatory field
	if f.TypeOneBooleanFilteredNotMandatory != nil && !f.TypeOneBooleanFilteredNotMandatory.Eval(obj.TypeOneBooleanFilteredNotMandatory) {
		return false
	}

	// Handle TypeOneSliceWithTypeTwos slice
	if f.TypeOneSliceWithTypeTwos != nil {
		for _, elem := range obj.TypeOneSliceWithTypeTwos {
			if !f.TypeOneSliceWithTypeTwos.Eval(elem) {
				return false
			}
		}
	}

	return true
}

///////////////////////////////// GENERIC TYPES /////////////////////////////////

func (f *FilterBoolean) Eval(val *bool) bool {
	if f == nil {
		return true
	}

	return rootEval(val, f.Exists, f.Eq, nil)
}

func (f *FilterNumber) Eval(val *int) bool {
	if f == nil {
		return true
	}

	if !rootEval(val, f.Exists, f.Eq, f.Neq) {
		return false
	}

	if val != nil && f.Gt != nil && *val <= *f.Gt {
		return false
	}

	if val != nil && f.Lt != nil && *val >= *f.Lt {
		return false
	}

	return true
}

func (f *FilterString) Eval(val *string) bool {
	if f == nil {
		return true
	}

	if !rootEval(val, f.Exists, f.Eq, f.Neq) {
		return false
	}

	if val != nil && f.Like != nil {
		matched, err := regexp.MatchString(*f.Like, *val)
		if err != nil || !matched {
			return false
		}
	}

	if val != nil && f.Nlike != nil {
		matched, err := regexp.MatchString(*f.Nlike, *val)
		if err != nil || matched {
			return false
		}
	}

	return true
}

// Eval evaluates the FilterTime conditions against a given time.Time value
func (f *FilterTime) Eval(val *time.Time) bool {
	if f == nil {
		return true
	}

	if !rootEval(val, f.Exists, f.Eq, f.Neq) {
		return false
	}

	// Check if the value is before the specified time
	if f.Before != nil && !val.Before(*f.Before) {
		return false
	}

	// Check if the value is after the specified time
	if f.After != nil && !val.After(*f.After) {
		return false
	}

	return true
}

// rootEval is a generic function that checks if the provided value matches the filter conditions.
func rootEval[T comparable](val *T, exists *bool, eq *T, neq *T) bool {
	// Check the Exists filter
	if exists != nil {
		if *exists && val == nil {
			return false
		}
		if !*exists && val != nil {
			return false
		}
	}

	// If val is nil and we reach this point, skip the following checks
	if val == nil {
		return true
	}

	// Check the Eq filter
	if eq != nil && *eq != *val {
		return false
	}

	// Check the Neq filter
	if neq != nil && *neq == *val {
		return false
	}

	return true
}
