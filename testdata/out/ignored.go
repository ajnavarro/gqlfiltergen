// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package out

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
}

type DirectiveRoot struct {
	Filterable func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	FilterBoolean struct {
		Eq     func(childComplexity int) int
		Exists func(childComplexity int) int
	}

	FilterNumber struct {
		Eq     func(childComplexity int) int
		Exists func(childComplexity int) int
		Gt     func(childComplexity int) int
		Lt     func(childComplexity int) int
		Neq    func(childComplexity int) int
	}

	FilterString struct {
		Eq     func(childComplexity int) int
		Exists func(childComplexity int) int
		Like   func(childComplexity int) int
		Neq    func(childComplexity int) int
		Nlike  func(childComplexity int) int
	}

	FilterTime struct {
		After  func(childComplexity int) int
		Before func(childComplexity int) int
		Eq     func(childComplexity int) int
		Exists func(childComplexity int) int
		Neq    func(childComplexity int) int
	}

	FilterTypeOne struct {
		And                                    func(childComplexity int) int
		Not                                    func(childComplexity int) int
		Or                                     func(childComplexity int) int
		TypeOneBooleanFiltered                 func(childComplexity int) int
		TypeOneBooleanFilteredNotMandatory     func(childComplexity int) int
		TypeOneNumberFieldFiltered             func(childComplexity int) int
		TypeOneNumberFieldFilteredNotMandatory func(childComplexity int) int
		TypeOneSliceWithTypeTwos               func(childComplexity int) int
		TypeOneStringFieldFiltered             func(childComplexity int) int
		TypeOneStringFieldFilteredNotMandatory func(childComplexity int) int
		TypeOneTimeFieldFiltered               func(childComplexity int) int
		TypeOneTimeFieldFilteredNotMandatory   func(childComplexity int) int
	}

	FilterTypeThree struct {
		And                          func(childComplexity int) int
		Not                          func(childComplexity int) int
		Or                           func(childComplexity int) int
		TypeThreeBooleanFiltered     func(childComplexity int) int
		TypeThreeNumberFieldFiltered func(childComplexity int) int
		TypeThreeStringFieldFiltered func(childComplexity int) int
		TypeThreeTimeFieldFiltered   func(childComplexity int) int
	}

	FilterTypeTwo struct {
		And                              func(childComplexity int) int
		Not                              func(childComplexity int) int
		Or                               func(childComplexity int) int
		TypeTwoBooleanFiltered           func(childComplexity int) int
		TypeTwoNumberFieldFiltered       func(childComplexity int) int
		TypeTwoSliceWithTypeTwos         func(childComplexity int) int
		TypeTwoStringFieldFiltered       func(childComplexity int) int
		TypeTwoTimeFieldFiltered         func(childComplexity int) int
		TypeTwoWithTypeThree             func(childComplexity int) int
		TypeTwoWithTypeThreeNotMandatory func(childComplexity int) int
	}

	NestedFilterTypeThree struct {
		And                          func(childComplexity int) int
		Not                          func(childComplexity int) int
		Or                           func(childComplexity int) int
		TypeThreeBooleanFiltered     func(childComplexity int) int
		TypeThreeNumberFieldFiltered func(childComplexity int) int
		TypeThreeStringFieldFiltered func(childComplexity int) int
		TypeThreeTimeFieldFiltered   func(childComplexity int) int
	}

	NestedFilterTypeTwo struct {
		And                              func(childComplexity int) int
		Not                              func(childComplexity int) int
		Or                               func(childComplexity int) int
		TypeTwoBooleanFiltered           func(childComplexity int) int
		TypeTwoNumberFieldFiltered       func(childComplexity int) int
		TypeTwoSliceWithTypeTwos         func(childComplexity int) int
		TypeTwoStringFieldFiltered       func(childComplexity int) int
		TypeTwoTimeFieldFiltered         func(childComplexity int) int
		TypeTwoWithTypeThree             func(childComplexity int) int
		TypeTwoWithTypeThreeNotMandatory func(childComplexity int) int
	}

	Query struct {
	}

	TypeOne struct {
		TypeOneBooleanFiltered                 func(childComplexity int) int
		TypeOneBooleanFilteredNotMandatory     func(childComplexity int) int
		TypeOneNumberFieldFiltered             func(childComplexity int) int
		TypeOneNumberFieldFilteredNotMandatory func(childComplexity int) int
		TypeOneNumberFieldWithNoFilter         func(childComplexity int) int
		TypeOneSliceWithTypeTwos               func(childComplexity int) int
		TypeOneStringFieldFiltered             func(childComplexity int) int
		TypeOneStringFieldFilteredNotMandatory func(childComplexity int) int
		TypeOneStringFieldWithNoFilter         func(childComplexity int) int
		TypeOneTimeFieldFiltered               func(childComplexity int) int
		TypeOneTimeFieldFilteredNotMandatory   func(childComplexity int) int
		TypeOneTimeFieldWithNoFilter           func(childComplexity int) int
	}

	TypeThree struct {
		TypeThreeBooleanFiltered         func(childComplexity int) int
		TypeThreeNumberFieldFiltered     func(childComplexity int) int
		TypeThreeNumberFieldWithNoFilter func(childComplexity int) int
		TypeThreeStringFieldFiltered     func(childComplexity int) int
		TypeThreeStringFieldWithNoFilter func(childComplexity int) int
		TypeThreeTimeFieldFiltered       func(childComplexity int) int
		TypeThreeTimeFieldWithNoFilter   func(childComplexity int) int
	}

	TypeTwo struct {
		TypeTwoBooleanFiltered           func(childComplexity int) int
		TypeTwoNumberFieldFiltered       func(childComplexity int) int
		TypeTwoNumberFieldWithNoFilter   func(childComplexity int) int
		TypeTwoSliceWithTypeTwos         func(childComplexity int) int
		TypeTwoStringFieldFiltered       func(childComplexity int) int
		TypeTwoStringFieldWithNoFilter   func(childComplexity int) int
		TypeTwoTimeFieldFiltered         func(childComplexity int) int
		TypeTwoTimeFieldWithNoFilter     func(childComplexity int) int
		TypeTwoWithTypeThree             func(childComplexity int) int
		TypeTwoWithTypeThreeNotMandatory func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "FilterBoolean.eq":
		if e.complexity.FilterBoolean.Eq == nil {
			break
		}

		return e.complexity.FilterBoolean.Eq(childComplexity), true

	case "FilterBoolean.exists":
		if e.complexity.FilterBoolean.Exists == nil {
			break
		}

		return e.complexity.FilterBoolean.Exists(childComplexity), true

	case "FilterNumber.eq":
		if e.complexity.FilterNumber.Eq == nil {
			break
		}

		return e.complexity.FilterNumber.Eq(childComplexity), true

	case "FilterNumber.exists":
		if e.complexity.FilterNumber.Exists == nil {
			break
		}

		return e.complexity.FilterNumber.Exists(childComplexity), true

	case "FilterNumber.gt":
		if e.complexity.FilterNumber.Gt == nil {
			break
		}

		return e.complexity.FilterNumber.Gt(childComplexity), true

	case "FilterNumber.lt":
		if e.complexity.FilterNumber.Lt == nil {
			break
		}

		return e.complexity.FilterNumber.Lt(childComplexity), true

	case "FilterNumber.neq":
		if e.complexity.FilterNumber.Neq == nil {
			break
		}

		return e.complexity.FilterNumber.Neq(childComplexity), true

	case "FilterString.eq":
		if e.complexity.FilterString.Eq == nil {
			break
		}

		return e.complexity.FilterString.Eq(childComplexity), true

	case "FilterString.exists":
		if e.complexity.FilterString.Exists == nil {
			break
		}

		return e.complexity.FilterString.Exists(childComplexity), true

	case "FilterString.like":
		if e.complexity.FilterString.Like == nil {
			break
		}

		return e.complexity.FilterString.Like(childComplexity), true

	case "FilterString.neq":
		if e.complexity.FilterString.Neq == nil {
			break
		}

		return e.complexity.FilterString.Neq(childComplexity), true

	case "FilterString.nlike":
		if e.complexity.FilterString.Nlike == nil {
			break
		}

		return e.complexity.FilterString.Nlike(childComplexity), true

	case "FilterTime.after":
		if e.complexity.FilterTime.After == nil {
			break
		}

		return e.complexity.FilterTime.After(childComplexity), true

	case "FilterTime.before":
		if e.complexity.FilterTime.Before == nil {
			break
		}

		return e.complexity.FilterTime.Before(childComplexity), true

	case "FilterTime.eq":
		if e.complexity.FilterTime.Eq == nil {
			break
		}

		return e.complexity.FilterTime.Eq(childComplexity), true

	case "FilterTime.exists":
		if e.complexity.FilterTime.Exists == nil {
			break
		}

		return e.complexity.FilterTime.Exists(childComplexity), true

	case "FilterTime.neq":
		if e.complexity.FilterTime.Neq == nil {
			break
		}

		return e.complexity.FilterTime.Neq(childComplexity), true

	case "FilterTypeOne._and":
		if e.complexity.FilterTypeOne.And == nil {
			break
		}

		return e.complexity.FilterTypeOne.And(childComplexity), true

	case "FilterTypeOne._not":
		if e.complexity.FilterTypeOne.Not == nil {
			break
		}

		return e.complexity.FilterTypeOne.Not(childComplexity), true

	case "FilterTypeOne._or":
		if e.complexity.FilterTypeOne.Or == nil {
			break
		}

		return e.complexity.FilterTypeOne.Or(childComplexity), true

	case "FilterTypeOne.typeOneBooleanFiltered":
		if e.complexity.FilterTypeOne.TypeOneBooleanFiltered == nil {
			break
		}

		return e.complexity.FilterTypeOne.TypeOneBooleanFiltered(childComplexity), true

	case "FilterTypeOne.typeOneBooleanFilteredNotMandatory":
		if e.complexity.FilterTypeOne.TypeOneBooleanFilteredNotMandatory == nil {
			break
		}

		return e.complexity.FilterTypeOne.TypeOneBooleanFilteredNotMandatory(childComplexity), true

	case "FilterTypeOne.typeOneNumberFieldFiltered":
		if e.complexity.FilterTypeOne.TypeOneNumberFieldFiltered == nil {
			break
		}

		return e.complexity.FilterTypeOne.TypeOneNumberFieldFiltered(childComplexity), true

	case "FilterTypeOne.typeOneNumberFieldFilteredNotMandatory":
		if e.complexity.FilterTypeOne.TypeOneNumberFieldFilteredNotMandatory == nil {
			break
		}

		return e.complexity.FilterTypeOne.TypeOneNumberFieldFilteredNotMandatory(childComplexity), true

	case "FilterTypeOne.typeOneSliceWithTypeTwos":
		if e.complexity.FilterTypeOne.TypeOneSliceWithTypeTwos == nil {
			break
		}

		return e.complexity.FilterTypeOne.TypeOneSliceWithTypeTwos(childComplexity), true

	case "FilterTypeOne.typeOneStringFieldFiltered":
		if e.complexity.FilterTypeOne.TypeOneStringFieldFiltered == nil {
			break
		}

		return e.complexity.FilterTypeOne.TypeOneStringFieldFiltered(childComplexity), true

	case "FilterTypeOne.typeOneStringFieldFilteredNotMandatory":
		if e.complexity.FilterTypeOne.TypeOneStringFieldFilteredNotMandatory == nil {
			break
		}

		return e.complexity.FilterTypeOne.TypeOneStringFieldFilteredNotMandatory(childComplexity), true

	case "FilterTypeOne.typeOneTimeFieldFiltered":
		if e.complexity.FilterTypeOne.TypeOneTimeFieldFiltered == nil {
			break
		}

		return e.complexity.FilterTypeOne.TypeOneTimeFieldFiltered(childComplexity), true

	case "FilterTypeOne.typeOneTimeFieldFilteredNotMandatory":
		if e.complexity.FilterTypeOne.TypeOneTimeFieldFilteredNotMandatory == nil {
			break
		}

		return e.complexity.FilterTypeOne.TypeOneTimeFieldFilteredNotMandatory(childComplexity), true

	case "FilterTypeThree._and":
		if e.complexity.FilterTypeThree.And == nil {
			break
		}

		return e.complexity.FilterTypeThree.And(childComplexity), true

	case "FilterTypeThree._not":
		if e.complexity.FilterTypeThree.Not == nil {
			break
		}

		return e.complexity.FilterTypeThree.Not(childComplexity), true

	case "FilterTypeThree._or":
		if e.complexity.FilterTypeThree.Or == nil {
			break
		}

		return e.complexity.FilterTypeThree.Or(childComplexity), true

	case "FilterTypeThree.typeThreeBooleanFiltered":
		if e.complexity.FilterTypeThree.TypeThreeBooleanFiltered == nil {
			break
		}

		return e.complexity.FilterTypeThree.TypeThreeBooleanFiltered(childComplexity), true

	case "FilterTypeThree.typeThreeNumberFieldFiltered":
		if e.complexity.FilterTypeThree.TypeThreeNumberFieldFiltered == nil {
			break
		}

		return e.complexity.FilterTypeThree.TypeThreeNumberFieldFiltered(childComplexity), true

	case "FilterTypeThree.typeThreeStringFieldFiltered":
		if e.complexity.FilterTypeThree.TypeThreeStringFieldFiltered == nil {
			break
		}

		return e.complexity.FilterTypeThree.TypeThreeStringFieldFiltered(childComplexity), true

	case "FilterTypeThree.typeThreeTimeFieldFiltered":
		if e.complexity.FilterTypeThree.TypeThreeTimeFieldFiltered == nil {
			break
		}

		return e.complexity.FilterTypeThree.TypeThreeTimeFieldFiltered(childComplexity), true

	case "FilterTypeTwo._and":
		if e.complexity.FilterTypeTwo.And == nil {
			break
		}

		return e.complexity.FilterTypeTwo.And(childComplexity), true

	case "FilterTypeTwo._not":
		if e.complexity.FilterTypeTwo.Not == nil {
			break
		}

		return e.complexity.FilterTypeTwo.Not(childComplexity), true

	case "FilterTypeTwo._or":
		if e.complexity.FilterTypeTwo.Or == nil {
			break
		}

		return e.complexity.FilterTypeTwo.Or(childComplexity), true

	case "FilterTypeTwo.typeTwoBooleanFiltered":
		if e.complexity.FilterTypeTwo.TypeTwoBooleanFiltered == nil {
			break
		}

		return e.complexity.FilterTypeTwo.TypeTwoBooleanFiltered(childComplexity), true

	case "FilterTypeTwo.typeTwoNumberFieldFiltered":
		if e.complexity.FilterTypeTwo.TypeTwoNumberFieldFiltered == nil {
			break
		}

		return e.complexity.FilterTypeTwo.TypeTwoNumberFieldFiltered(childComplexity), true

	case "FilterTypeTwo.typeTwoSliceWithTypeTwos":
		if e.complexity.FilterTypeTwo.TypeTwoSliceWithTypeTwos == nil {
			break
		}

		return e.complexity.FilterTypeTwo.TypeTwoSliceWithTypeTwos(childComplexity), true

	case "FilterTypeTwo.typeTwoStringFieldFiltered":
		if e.complexity.FilterTypeTwo.TypeTwoStringFieldFiltered == nil {
			break
		}

		return e.complexity.FilterTypeTwo.TypeTwoStringFieldFiltered(childComplexity), true

	case "FilterTypeTwo.typeTwoTimeFieldFiltered":
		if e.complexity.FilterTypeTwo.TypeTwoTimeFieldFiltered == nil {
			break
		}

		return e.complexity.FilterTypeTwo.TypeTwoTimeFieldFiltered(childComplexity), true

	case "FilterTypeTwo.typeTwoWithTypeThree":
		if e.complexity.FilterTypeTwo.TypeTwoWithTypeThree == nil {
			break
		}

		return e.complexity.FilterTypeTwo.TypeTwoWithTypeThree(childComplexity), true

	case "FilterTypeTwo.typeTwoWithTypeThreeNotMandatory":
		if e.complexity.FilterTypeTwo.TypeTwoWithTypeThreeNotMandatory == nil {
			break
		}

		return e.complexity.FilterTypeTwo.TypeTwoWithTypeThreeNotMandatory(childComplexity), true

	case "NestedFilterTypeThree._and":
		if e.complexity.NestedFilterTypeThree.And == nil {
			break
		}

		return e.complexity.NestedFilterTypeThree.And(childComplexity), true

	case "NestedFilterTypeThree._not":
		if e.complexity.NestedFilterTypeThree.Not == nil {
			break
		}

		return e.complexity.NestedFilterTypeThree.Not(childComplexity), true

	case "NestedFilterTypeThree._or":
		if e.complexity.NestedFilterTypeThree.Or == nil {
			break
		}

		return e.complexity.NestedFilterTypeThree.Or(childComplexity), true

	case "NestedFilterTypeThree.typeThreeBooleanFiltered":
		if e.complexity.NestedFilterTypeThree.TypeThreeBooleanFiltered == nil {
			break
		}

		return e.complexity.NestedFilterTypeThree.TypeThreeBooleanFiltered(childComplexity), true

	case "NestedFilterTypeThree.typeThreeNumberFieldFiltered":
		if e.complexity.NestedFilterTypeThree.TypeThreeNumberFieldFiltered == nil {
			break
		}

		return e.complexity.NestedFilterTypeThree.TypeThreeNumberFieldFiltered(childComplexity), true

	case "NestedFilterTypeThree.typeThreeStringFieldFiltered":
		if e.complexity.NestedFilterTypeThree.TypeThreeStringFieldFiltered == nil {
			break
		}

		return e.complexity.NestedFilterTypeThree.TypeThreeStringFieldFiltered(childComplexity), true

	case "NestedFilterTypeThree.typeThreeTimeFieldFiltered":
		if e.complexity.NestedFilterTypeThree.TypeThreeTimeFieldFiltered == nil {
			break
		}

		return e.complexity.NestedFilterTypeThree.TypeThreeTimeFieldFiltered(childComplexity), true

	case "NestedFilterTypeTwo._and":
		if e.complexity.NestedFilterTypeTwo.And == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.And(childComplexity), true

	case "NestedFilterTypeTwo._not":
		if e.complexity.NestedFilterTypeTwo.Not == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.Not(childComplexity), true

	case "NestedFilterTypeTwo._or":
		if e.complexity.NestedFilterTypeTwo.Or == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.Or(childComplexity), true

	case "NestedFilterTypeTwo.typeTwoBooleanFiltered":
		if e.complexity.NestedFilterTypeTwo.TypeTwoBooleanFiltered == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.TypeTwoBooleanFiltered(childComplexity), true

	case "NestedFilterTypeTwo.typeTwoNumberFieldFiltered":
		if e.complexity.NestedFilterTypeTwo.TypeTwoNumberFieldFiltered == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.TypeTwoNumberFieldFiltered(childComplexity), true

	case "NestedFilterTypeTwo.typeTwoSliceWithTypeTwos":
		if e.complexity.NestedFilterTypeTwo.TypeTwoSliceWithTypeTwos == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.TypeTwoSliceWithTypeTwos(childComplexity), true

	case "NestedFilterTypeTwo.typeTwoStringFieldFiltered":
		if e.complexity.NestedFilterTypeTwo.TypeTwoStringFieldFiltered == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.TypeTwoStringFieldFiltered(childComplexity), true

	case "NestedFilterTypeTwo.typeTwoTimeFieldFiltered":
		if e.complexity.NestedFilterTypeTwo.TypeTwoTimeFieldFiltered == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.TypeTwoTimeFieldFiltered(childComplexity), true

	case "NestedFilterTypeTwo.typeTwoWithTypeThree":
		if e.complexity.NestedFilterTypeTwo.TypeTwoWithTypeThree == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.TypeTwoWithTypeThree(childComplexity), true

	case "NestedFilterTypeTwo.typeTwoWithTypeThreeNotMandatory":
		if e.complexity.NestedFilterTypeTwo.TypeTwoWithTypeThreeNotMandatory == nil {
			break
		}

		return e.complexity.NestedFilterTypeTwo.TypeTwoWithTypeThreeNotMandatory(childComplexity), true

	case "TypeOne.typeOneBooleanFiltered":
		if e.complexity.TypeOne.TypeOneBooleanFiltered == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneBooleanFiltered(childComplexity), true

	case "TypeOne.typeOneBooleanFilteredNotMandatory":
		if e.complexity.TypeOne.TypeOneBooleanFilteredNotMandatory == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneBooleanFilteredNotMandatory(childComplexity), true

	case "TypeOne.typeOneNumberFieldFiltered":
		if e.complexity.TypeOne.TypeOneNumberFieldFiltered == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneNumberFieldFiltered(childComplexity), true

	case "TypeOne.typeOneNumberFieldFilteredNotMandatory":
		if e.complexity.TypeOne.TypeOneNumberFieldFilteredNotMandatory == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneNumberFieldFilteredNotMandatory(childComplexity), true

	case "TypeOne.typeOneNumberFieldWithNoFilter":
		if e.complexity.TypeOne.TypeOneNumberFieldWithNoFilter == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneNumberFieldWithNoFilter(childComplexity), true

	case "TypeOne.typeOneSliceWithTypeTwos":
		if e.complexity.TypeOne.TypeOneSliceWithTypeTwos == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneSliceWithTypeTwos(childComplexity), true

	case "TypeOne.typeOneStringFieldFiltered":
		if e.complexity.TypeOne.TypeOneStringFieldFiltered == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneStringFieldFiltered(childComplexity), true

	case "TypeOne.typeOneStringFieldFilteredNotMandatory":
		if e.complexity.TypeOne.TypeOneStringFieldFilteredNotMandatory == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneStringFieldFilteredNotMandatory(childComplexity), true

	case "TypeOne.typeOneStringFieldWithNoFilter":
		if e.complexity.TypeOne.TypeOneStringFieldWithNoFilter == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneStringFieldWithNoFilter(childComplexity), true

	case "TypeOne.typeOneTimeFieldFiltered":
		if e.complexity.TypeOne.TypeOneTimeFieldFiltered == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneTimeFieldFiltered(childComplexity), true

	case "TypeOne.typeOneTimeFieldFilteredNotMandatory":
		if e.complexity.TypeOne.TypeOneTimeFieldFilteredNotMandatory == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneTimeFieldFilteredNotMandatory(childComplexity), true

	case "TypeOne.typeOneTimeFieldWithNoFilter":
		if e.complexity.TypeOne.TypeOneTimeFieldWithNoFilter == nil {
			break
		}

		return e.complexity.TypeOne.TypeOneTimeFieldWithNoFilter(childComplexity), true

	case "TypeThree.typeThreeBooleanFiltered":
		if e.complexity.TypeThree.TypeThreeBooleanFiltered == nil {
			break
		}

		return e.complexity.TypeThree.TypeThreeBooleanFiltered(childComplexity), true

	case "TypeThree.typeThreeNumberFieldFiltered":
		if e.complexity.TypeThree.TypeThreeNumberFieldFiltered == nil {
			break
		}

		return e.complexity.TypeThree.TypeThreeNumberFieldFiltered(childComplexity), true

	case "TypeThree.typeThreeNumberFieldWithNoFilter":
		if e.complexity.TypeThree.TypeThreeNumberFieldWithNoFilter == nil {
			break
		}

		return e.complexity.TypeThree.TypeThreeNumberFieldWithNoFilter(childComplexity), true

	case "TypeThree.typeThreeStringFieldFiltered":
		if e.complexity.TypeThree.TypeThreeStringFieldFiltered == nil {
			break
		}

		return e.complexity.TypeThree.TypeThreeStringFieldFiltered(childComplexity), true

	case "TypeThree.typeThreeStringFieldWithNoFilter":
		if e.complexity.TypeThree.TypeThreeStringFieldWithNoFilter == nil {
			break
		}

		return e.complexity.TypeThree.TypeThreeStringFieldWithNoFilter(childComplexity), true

	case "TypeThree.typeThreeTimeFieldFiltered":
		if e.complexity.TypeThree.TypeThreeTimeFieldFiltered == nil {
			break
		}

		return e.complexity.TypeThree.TypeThreeTimeFieldFiltered(childComplexity), true

	case "TypeThree.typeThreeTimeFieldWithNoFilter":
		if e.complexity.TypeThree.TypeThreeTimeFieldWithNoFilter == nil {
			break
		}

		return e.complexity.TypeThree.TypeThreeTimeFieldWithNoFilter(childComplexity), true

	case "TypeTwo.typeTwoBooleanFiltered":
		if e.complexity.TypeTwo.TypeTwoBooleanFiltered == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoBooleanFiltered(childComplexity), true

	case "TypeTwo.typeTwoNumberFieldFiltered":
		if e.complexity.TypeTwo.TypeTwoNumberFieldFiltered == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoNumberFieldFiltered(childComplexity), true

	case "TypeTwo.typeTwoNumberFieldWithNoFilter":
		if e.complexity.TypeTwo.TypeTwoNumberFieldWithNoFilter == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoNumberFieldWithNoFilter(childComplexity), true

	case "TypeTwo.typeTwoSliceWithTypeTwos":
		if e.complexity.TypeTwo.TypeTwoSliceWithTypeTwos == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoSliceWithTypeTwos(childComplexity), true

	case "TypeTwo.typeTwoStringFieldFiltered":
		if e.complexity.TypeTwo.TypeTwoStringFieldFiltered == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoStringFieldFiltered(childComplexity), true

	case "TypeTwo.typeTwoStringFieldWithNoFilter":
		if e.complexity.TypeTwo.TypeTwoStringFieldWithNoFilter == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoStringFieldWithNoFilter(childComplexity), true

	case "TypeTwo.typeTwoTimeFieldFiltered":
		if e.complexity.TypeTwo.TypeTwoTimeFieldFiltered == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoTimeFieldFiltered(childComplexity), true

	case "TypeTwo.typeTwoTimeFieldWithNoFilter":
		if e.complexity.TypeTwo.TypeTwoTimeFieldWithNoFilter == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoTimeFieldWithNoFilter(childComplexity), true

	case "TypeTwo.typeTwoWithTypeThree":
		if e.complexity.TypeTwo.TypeTwoWithTypeThree == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoWithTypeThree(childComplexity), true

	case "TypeTwo.typeTwoWithTypeThreeNotMandatory":
		if e.complexity.TypeTwo.TypeTwoWithTypeThreeNotMandatory == nil {
			break
		}

		return e.complexity.TypeTwo.TypeTwoWithTypeThreeNotMandatory(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphql", Input: `
scalar Time

type TypeOne {
  typeOneStringFieldFiltered: String! @filterable
  typeOneStringFieldFilteredNotMandatory: String @filterable
  typeOneNumberFieldFiltered: Int! @filterable
  typeOneNumberFieldFilteredNotMandatory: Int @filterable
  typeOneTimeFieldFiltered: Time! @filterable
  typeOneTimeFieldFilteredNotMandatory: Time @filterable
  typeOneBooleanFiltered: Boolean! @filterable
  typeOneBooleanFilteredNotMandatory: Boolean @filterable

  typeOneStringFieldWithNoFilter: String!
  typeOneNumberFieldWithNoFilter: Int!
  typeOneTimeFieldWithNoFilter: Time!

  typeOneSliceWithTypeTwos: [TypeTwo]! @filterable
}

type TypeTwo {
  typeTwoStringFieldFiltered: String! @filterable
  typeTwoNumberFieldFiltered: Int! @filterable
  typeTwoTimeFieldFiltered: Time! @filterable
  typeTwoBooleanFiltered: Boolean! @filterable

  typeTwoStringFieldWithNoFilter: String!
  typeTwoNumberFieldWithNoFilter: Int!
  typeTwoTimeFieldWithNoFilter: Time!

  typeTwoSliceWithTypeTwos: [TypeTwo]! @filterable

  typeTwoWithTypeThree: TypeThree! @filterable
  typeTwoWithTypeThreeNotMandatory: TypeThree @filterable

}

type TypeThree {
  typeThreeStringFieldFiltered: String! @filterable
  typeThreeNumberFieldFiltered: Int! @filterable
  typeThreeTimeFieldFiltered: Time! @filterable
  typeThreeBooleanFiltered: Boolean! @filterable

  typeThreeStringFieldWithNoFilter: String!
  typeThreeNumberFieldWithNoFilter: Int!
  typeThreeTimeFieldWithNoFilter: Time!
}
`, BuiltIn: false},
	{Name: "../../filtergen.directives.graphql", Input: `directive @filterable on FIELD_DEFINITION`, BuiltIn: false},
	{Name: "../../filtergen.graphql", Input: `"""
Filter type for boolean fields. All added filters here are processed as AND operators.
"""
type FilterBoolean {
	"""
	Filter a boolean field checking if it exists or not.
	"""
	exists: Boolean
	"""
	Filter a boolean field checking if it is equals to the specified value.
	"""
	eq: Boolean
}
"""
Filter type for number fields. All added filters here are processed as AND operators.
"""
type FilterNumber {
	"""
	Filter a number field checking if it exists or not.
	"""
	exists: Boolean
	"""
	Filter a number field checking if it is equals to the specified value.
	"""
	eq: Int
	"""
	Filter a number field checking if it is NOT equals to the specified value.
	"""
	neq: Int
	"""
	Filter a number field checking if it is greater than the specified value.
	"""
	gt: Int
	"""
	Filter a number field checking if it is less than the specified value.
	"""
	lt: Int
}
"""
Filter type for string fields. It contains a variety of filter types for string types. All added filters here are processed as AND operators.
"""
type FilterString {
	"""
	Filter a string field checking if it exists or not.
	"""
	exists: Boolean
	"""
	Filter a string field checking if it is equals to the specified value.
	"""
	eq: String
	"""
	Filter a string field checking if it is NOT equals to the specified value.
	"""
	neq: String
	"""
	Filter a string field checking if it is like the specified value. You can use standard Go RegEx expressions here.
	"""
	like: String
	"""
	Filter a string field checking if it is NOT like the specified value. You can use standard Go RegEx expressions here.
	"""
	nlike: String
}
"""
Filter type for time fields. All added filters here are processed as AND operators.
"""
type FilterTime {
	"""
	Filter a time field checking if it exists or not.
	"""
	exists: Boolean
	"""
	Filter a time field checking if it is equals to the specified value.
	"""
	eq: Time
	"""
	Filter a time field checking if it is NOT equals to the specified value.
	"""
	neq: Time
	"""
	Filter a time field checking if it is before than the specified value.
	"""
	before: Time
	"""
	Filter a time field checking if it is after the specified value.
	"""
	after: Time
}
"""
filter for TypeOne objects
"""
type FilterTypeOne {
	"""
	logical operator for TypeOne that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterTypeOne]
	"""
	logical operator for TypeOne that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterTypeOne]
	"""
	logical operator for TypeOne that will reverse conditions.
	"""
	_not: FilterTypeOne
	"""
	filter for typeOneStringFieldFiltered field.
	"""
	typeOneStringFieldFiltered: FilterString
	"""
	filter for typeOneStringFieldFilteredNotMandatory field.
	"""
	typeOneStringFieldFilteredNotMandatory: FilterString
	"""
	filter for typeOneNumberFieldFiltered field.
	"""
	typeOneNumberFieldFiltered: FilterNumber
	"""
	filter for typeOneNumberFieldFilteredNotMandatory field.
	"""
	typeOneNumberFieldFilteredNotMandatory: FilterNumber
	"""
	filter for typeOneTimeFieldFiltered field.
	"""
	typeOneTimeFieldFiltered: FilterTime
	"""
	filter for typeOneTimeFieldFilteredNotMandatory field.
	"""
	typeOneTimeFieldFilteredNotMandatory: FilterTime
	"""
	filter for typeOneBooleanFiltered field.
	"""
	typeOneBooleanFiltered: FilterBoolean
	"""
	filter for typeOneBooleanFilteredNotMandatory field.
	"""
	typeOneBooleanFilteredNotMandatory: FilterBoolean
	"""
	filter for typeOneSliceWithTypeTwos field.
	"""
	typeOneSliceWithTypeTwos: NestedFilterTypeTwo
}
"""
filter for TypeThree objects
"""
type FilterTypeThree {
	"""
	logical operator for TypeThree that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterTypeThree]
	"""
	logical operator for TypeThree that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterTypeThree]
	"""
	logical operator for TypeThree that will reverse conditions.
	"""
	_not: FilterTypeThree
	"""
	filter for typeThreeStringFieldFiltered field.
	"""
	typeThreeStringFieldFiltered: FilterString
	"""
	filter for typeThreeNumberFieldFiltered field.
	"""
	typeThreeNumberFieldFiltered: FilterNumber
	"""
	filter for typeThreeTimeFieldFiltered field.
	"""
	typeThreeTimeFieldFiltered: FilterTime
	"""
	filter for typeThreeBooleanFiltered field.
	"""
	typeThreeBooleanFiltered: FilterBoolean
}
"""
filter for TypeTwo objects
"""
type FilterTypeTwo {
	"""
	logical operator for TypeTwo that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterTypeTwo]
	"""
	logical operator for TypeTwo that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterTypeTwo]
	"""
	logical operator for TypeTwo that will reverse conditions.
	"""
	_not: FilterTypeTwo
	"""
	filter for typeTwoStringFieldFiltered field.
	"""
	typeTwoStringFieldFiltered: FilterString
	"""
	filter for typeTwoNumberFieldFiltered field.
	"""
	typeTwoNumberFieldFiltered: FilterNumber
	"""
	filter for typeTwoTimeFieldFiltered field.
	"""
	typeTwoTimeFieldFiltered: FilterTime
	"""
	filter for typeTwoBooleanFiltered field.
	"""
	typeTwoBooleanFiltered: FilterBoolean
	"""
	filter for typeTwoSliceWithTypeTwos field.
	"""
	typeTwoSliceWithTypeTwos: NestedFilterTypeTwo
	"""
	filter for typeTwoWithTypeThree field.
	"""
	typeTwoWithTypeThree: NestedFilterTypeThree
	"""
	filter for typeTwoWithTypeThreeNotMandatory field.
	"""
	typeTwoWithTypeThreeNotMandatory: NestedFilterTypeThree
}
"""
filter for TypeThree objects
"""
type NestedFilterTypeThree {
	"""
	logical operator for TypeThree that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterTypeThree]
	"""
	logical operator for TypeThree that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterTypeThree]
	"""
	logical operator for TypeThree that will reverse conditions.
	"""
	_not: NestedFilterTypeThree
	"""
	filter for typeThreeStringFieldFiltered field.
	"""
	typeThreeStringFieldFiltered: FilterString
	"""
	filter for typeThreeNumberFieldFiltered field.
	"""
	typeThreeNumberFieldFiltered: FilterNumber
	"""
	filter for typeThreeTimeFieldFiltered field.
	"""
	typeThreeTimeFieldFiltered: FilterTime
	"""
	filter for typeThreeBooleanFiltered field.
	"""
	typeThreeBooleanFiltered: FilterBoolean
}
"""
filter for TypeTwo objects
"""
type NestedFilterTypeTwo {
	"""
	logical operator for TypeTwo that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterTypeTwo]
	"""
	logical operator for TypeTwo that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterTypeTwo]
	"""
	logical operator for TypeTwo that will reverse conditions.
	"""
	_not: NestedFilterTypeTwo
	"""
	filter for typeTwoStringFieldFiltered field.
	"""
	typeTwoStringFieldFiltered: FilterString
	"""
	filter for typeTwoNumberFieldFiltered field.
	"""
	typeTwoNumberFieldFiltered: FilterNumber
	"""
	filter for typeTwoTimeFieldFiltered field.
	"""
	typeTwoTimeFieldFiltered: FilterTime
	"""
	filter for typeTwoBooleanFiltered field.
	"""
	typeTwoBooleanFiltered: FilterBoolean
	"""
	filter for typeTwoSliceWithTypeTwos field.
	"""
	typeTwoSliceWithTypeTwos: NestedFilterTypeTwo
	"""
	filter for typeTwoWithTypeThree field.
	"""
	typeTwoWithTypeThree: NestedFilterTypeThree
	"""
	filter for typeTwoWithTypeThreeNotMandatory field.
	"""
	typeTwoWithTypeThreeNotMandatory: NestedFilterTypeThree
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _FilterBoolean_exists(ctx context.Context, field graphql.CollectedField, obj *FilterBoolean) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterBoolean_exists(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterBoolean_exists(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterBoolean",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterBoolean_eq(ctx context.Context, field graphql.CollectedField, obj *FilterBoolean) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterBoolean_eq(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Eq, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterBoolean_eq(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterBoolean",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterNumber_exists(ctx context.Context, field graphql.CollectedField, obj *FilterNumber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterNumber_exists(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterNumber_exists(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterNumber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterNumber_eq(ctx context.Context, field graphql.CollectedField, obj *FilterNumber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterNumber_eq(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Eq, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterNumber_eq(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterNumber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterNumber_neq(ctx context.Context, field graphql.CollectedField, obj *FilterNumber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterNumber_neq(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Neq, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterNumber_neq(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterNumber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterNumber_gt(ctx context.Context, field graphql.CollectedField, obj *FilterNumber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterNumber_gt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterNumber_gt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterNumber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterNumber_lt(ctx context.Context, field graphql.CollectedField, obj *FilterNumber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterNumber_lt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterNumber_lt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterNumber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterString_exists(ctx context.Context, field graphql.CollectedField, obj *FilterString) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterString_exists(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterString_exists(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterString",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterString_eq(ctx context.Context, field graphql.CollectedField, obj *FilterString) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterString_eq(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Eq, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterString_eq(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterString",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterString_neq(ctx context.Context, field graphql.CollectedField, obj *FilterString) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterString_neq(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Neq, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterString_neq(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterString",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterString_like(ctx context.Context, field graphql.CollectedField, obj *FilterString) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterString_like(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Like, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterString_like(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterString",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterString_nlike(ctx context.Context, field graphql.CollectedField, obj *FilterString) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterString_nlike(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nlike, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterString_nlike(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterString",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTime_exists(ctx context.Context, field graphql.CollectedField, obj *FilterTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTime_exists(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTime_exists(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTime_eq(ctx context.Context, field graphql.CollectedField, obj *FilterTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTime_eq(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Eq, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTime_eq(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTime_neq(ctx context.Context, field graphql.CollectedField, obj *FilterTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTime_neq(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Neq, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTime_neq(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTime_before(ctx context.Context, field graphql.CollectedField, obj *FilterTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTime_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTime_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTime_after(ctx context.Context, field graphql.CollectedField, obj *FilterTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTime_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTime_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne__and(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne__and(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.And, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FilterTypeOne)
	fc.Result = res
	return ec.marshalOFilterTypeOne2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeOne(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne__and(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_FilterTypeOne__and(ctx, field)
			case "_or":
				return ec.fieldContext_FilterTypeOne__or(ctx, field)
			case "_not":
				return ec.fieldContext_FilterTypeOne__not(ctx, field)
			case "typeOneStringFieldFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneStringFieldFiltered(ctx, field)
			case "typeOneStringFieldFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneStringFieldFilteredNotMandatory(ctx, field)
			case "typeOneNumberFieldFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneNumberFieldFiltered(ctx, field)
			case "typeOneNumberFieldFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneNumberFieldFilteredNotMandatory(ctx, field)
			case "typeOneTimeFieldFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneTimeFieldFiltered(ctx, field)
			case "typeOneTimeFieldFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneTimeFieldFilteredNotMandatory(ctx, field)
			case "typeOneBooleanFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneBooleanFiltered(ctx, field)
			case "typeOneBooleanFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneBooleanFilteredNotMandatory(ctx, field)
			case "typeOneSliceWithTypeTwos":
				return ec.fieldContext_FilterTypeOne_typeOneSliceWithTypeTwos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTypeOne", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne__or(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne__or(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Or, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FilterTypeOne)
	fc.Result = res
	return ec.marshalOFilterTypeOne2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeOne(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne__or(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_FilterTypeOne__and(ctx, field)
			case "_or":
				return ec.fieldContext_FilterTypeOne__or(ctx, field)
			case "_not":
				return ec.fieldContext_FilterTypeOne__not(ctx, field)
			case "typeOneStringFieldFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneStringFieldFiltered(ctx, field)
			case "typeOneStringFieldFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneStringFieldFilteredNotMandatory(ctx, field)
			case "typeOneNumberFieldFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneNumberFieldFiltered(ctx, field)
			case "typeOneNumberFieldFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneNumberFieldFilteredNotMandatory(ctx, field)
			case "typeOneTimeFieldFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneTimeFieldFiltered(ctx, field)
			case "typeOneTimeFieldFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneTimeFieldFilteredNotMandatory(ctx, field)
			case "typeOneBooleanFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneBooleanFiltered(ctx, field)
			case "typeOneBooleanFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneBooleanFilteredNotMandatory(ctx, field)
			case "typeOneSliceWithTypeTwos":
				return ec.fieldContext_FilterTypeOne_typeOneSliceWithTypeTwos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTypeOne", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne__not(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne__not(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Not, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterTypeOne)
	fc.Result = res
	return ec.marshalOFilterTypeOne2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeOne(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne__not(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_FilterTypeOne__and(ctx, field)
			case "_or":
				return ec.fieldContext_FilterTypeOne__or(ctx, field)
			case "_not":
				return ec.fieldContext_FilterTypeOne__not(ctx, field)
			case "typeOneStringFieldFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneStringFieldFiltered(ctx, field)
			case "typeOneStringFieldFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneStringFieldFilteredNotMandatory(ctx, field)
			case "typeOneNumberFieldFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneNumberFieldFiltered(ctx, field)
			case "typeOneNumberFieldFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneNumberFieldFilteredNotMandatory(ctx, field)
			case "typeOneTimeFieldFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneTimeFieldFiltered(ctx, field)
			case "typeOneTimeFieldFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneTimeFieldFilteredNotMandatory(ctx, field)
			case "typeOneBooleanFiltered":
				return ec.fieldContext_FilterTypeOne_typeOneBooleanFiltered(ctx, field)
			case "typeOneBooleanFilteredNotMandatory":
				return ec.fieldContext_FilterTypeOne_typeOneBooleanFilteredNotMandatory(ctx, field)
			case "typeOneSliceWithTypeTwos":
				return ec.fieldContext_FilterTypeOne_typeOneSliceWithTypeTwos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTypeOne", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne_typeOneStringFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne_typeOneStringFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneStringFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterString)
	fc.Result = res
	return ec.marshalOFilterString2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne_typeOneStringFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterString_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterString_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterString_neq(ctx, field)
			case "like":
				return ec.fieldContext_FilterString_like(ctx, field)
			case "nlike":
				return ec.fieldContext_FilterString_nlike(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterString", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne_typeOneStringFieldFilteredNotMandatory(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne_typeOneStringFieldFilteredNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneStringFieldFilteredNotMandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterString)
	fc.Result = res
	return ec.marshalOFilterString2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne_typeOneStringFieldFilteredNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterString_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterString_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterString_neq(ctx, field)
			case "like":
				return ec.fieldContext_FilterString_like(ctx, field)
			case "nlike":
				return ec.fieldContext_FilterString_nlike(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterString", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne_typeOneNumberFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne_typeOneNumberFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneNumberFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterNumber)
	fc.Result = res
	return ec.marshalOFilterNumber2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterNumber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne_typeOneNumberFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterNumber_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterNumber_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterNumber_neq(ctx, field)
			case "gt":
				return ec.fieldContext_FilterNumber_gt(ctx, field)
			case "lt":
				return ec.fieldContext_FilterNumber_lt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterNumber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne_typeOneNumberFieldFilteredNotMandatory(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne_typeOneNumberFieldFilteredNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneNumberFieldFilteredNotMandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterNumber)
	fc.Result = res
	return ec.marshalOFilterNumber2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterNumber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne_typeOneNumberFieldFilteredNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterNumber_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterNumber_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterNumber_neq(ctx, field)
			case "gt":
				return ec.fieldContext_FilterNumber_gt(ctx, field)
			case "lt":
				return ec.fieldContext_FilterNumber_lt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterNumber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne_typeOneTimeFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne_typeOneTimeFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneTimeFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterTime)
	fc.Result = res
	return ec.marshalOFilterTime2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne_typeOneTimeFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterTime_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterTime_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterTime_neq(ctx, field)
			case "before":
				return ec.fieldContext_FilterTime_before(ctx, field)
			case "after":
				return ec.fieldContext_FilterTime_after(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne_typeOneTimeFieldFilteredNotMandatory(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne_typeOneTimeFieldFilteredNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneTimeFieldFilteredNotMandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterTime)
	fc.Result = res
	return ec.marshalOFilterTime2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne_typeOneTimeFieldFilteredNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterTime_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterTime_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterTime_neq(ctx, field)
			case "before":
				return ec.fieldContext_FilterTime_before(ctx, field)
			case "after":
				return ec.fieldContext_FilterTime_after(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne_typeOneBooleanFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne_typeOneBooleanFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneBooleanFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterBoolean)
	fc.Result = res
	return ec.marshalOFilterBoolean2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterBoolean(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne_typeOneBooleanFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterBoolean_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterBoolean_eq(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterBoolean", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne_typeOneBooleanFilteredNotMandatory(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne_typeOneBooleanFilteredNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneBooleanFilteredNotMandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterBoolean)
	fc.Result = res
	return ec.marshalOFilterBoolean2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterBoolean(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne_typeOneBooleanFilteredNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterBoolean_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterBoolean_eq(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterBoolean", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeOne_typeOneSliceWithTypeTwos(ctx context.Context, field graphql.CollectedField, obj *FilterTypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeOne_typeOneSliceWithTypeTwos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneSliceWithTypeTwos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NestedFilterTypeTwo)
	fc.Result = res
	return ec.marshalONestedFilterTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeOne_typeOneSliceWithTypeTwos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeTwo__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeTwo__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeTwo__not(ctx, field)
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeThree__and(ctx context.Context, field graphql.CollectedField, obj *FilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeThree__and(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.And, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FilterTypeThree)
	fc.Result = res
	return ec.marshalOFilterTypeThree2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeThree__and(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_FilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_FilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_FilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeThree__or(ctx context.Context, field graphql.CollectedField, obj *FilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeThree__or(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Or, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FilterTypeThree)
	fc.Result = res
	return ec.marshalOFilterTypeThree2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeThree__or(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_FilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_FilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_FilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeThree__not(ctx context.Context, field graphql.CollectedField, obj *FilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeThree__not(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Not, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterTypeThree)
	fc.Result = res
	return ec.marshalOFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeThree__not(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_FilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_FilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_FilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_FilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeThree_typeThreeStringFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeStringFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterString)
	fc.Result = res
	return ec.marshalOFilterString2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeThree_typeThreeStringFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterString_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterString_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterString_neq(ctx, field)
			case "like":
				return ec.fieldContext_FilterString_like(ctx, field)
			case "nlike":
				return ec.fieldContext_FilterString_nlike(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterString", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeThree_typeThreeNumberFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeNumberFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterNumber)
	fc.Result = res
	return ec.marshalOFilterNumber2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterNumber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeThree_typeThreeNumberFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterNumber_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterNumber_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterNumber_neq(ctx, field)
			case "gt":
				return ec.fieldContext_FilterNumber_gt(ctx, field)
			case "lt":
				return ec.fieldContext_FilterNumber_lt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterNumber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeThree_typeThreeTimeFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeTimeFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterTime)
	fc.Result = res
	return ec.marshalOFilterTime2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeThree_typeThreeTimeFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterTime_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterTime_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterTime_neq(ctx, field)
			case "before":
				return ec.fieldContext_FilterTime_before(ctx, field)
			case "after":
				return ec.fieldContext_FilterTime_after(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeThree_typeThreeBooleanFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeThree_typeThreeBooleanFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeBooleanFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterBoolean)
	fc.Result = res
	return ec.marshalOFilterBoolean2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterBoolean(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeThree_typeThreeBooleanFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterBoolean_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterBoolean_eq(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterBoolean", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo__and(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo__and(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.And, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FilterTypeTwo)
	fc.Result = res
	return ec.marshalOFilterTypeTwo2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo__and(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_FilterTypeTwo__and(ctx, field)
			case "_or":
				return ec.fieldContext_FilterTypeTwo__or(ctx, field)
			case "_not":
				return ec.fieldContext_FilterTypeTwo__not(ctx, field)
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_FilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_FilterTypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_FilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo__or(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo__or(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Or, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*FilterTypeTwo)
	fc.Result = res
	return ec.marshalOFilterTypeTwo2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo__or(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_FilterTypeTwo__and(ctx, field)
			case "_or":
				return ec.fieldContext_FilterTypeTwo__or(ctx, field)
			case "_not":
				return ec.fieldContext_FilterTypeTwo__not(ctx, field)
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_FilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_FilterTypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_FilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo__not(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo__not(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Not, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterTypeTwo)
	fc.Result = res
	return ec.marshalOFilterTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo__not(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_FilterTypeTwo__and(ctx, field)
			case "_or":
				return ec.fieldContext_FilterTypeTwo__or(ctx, field)
			case "_not":
				return ec.fieldContext_FilterTypeTwo__not(ctx, field)
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_FilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_FilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_FilterTypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_FilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo_typeTwoStringFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoStringFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterString)
	fc.Result = res
	return ec.marshalOFilterString2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo_typeTwoStringFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterString_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterString_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterString_neq(ctx, field)
			case "like":
				return ec.fieldContext_FilterString_like(ctx, field)
			case "nlike":
				return ec.fieldContext_FilterString_nlike(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterString", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo_typeTwoNumberFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoNumberFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterNumber)
	fc.Result = res
	return ec.marshalOFilterNumber2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterNumber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo_typeTwoNumberFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterNumber_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterNumber_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterNumber_neq(ctx, field)
			case "gt":
				return ec.fieldContext_FilterNumber_gt(ctx, field)
			case "lt":
				return ec.fieldContext_FilterNumber_lt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterNumber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo_typeTwoTimeFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoTimeFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterTime)
	fc.Result = res
	return ec.marshalOFilterTime2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo_typeTwoTimeFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterTime_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterTime_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterTime_neq(ctx, field)
			case "before":
				return ec.fieldContext_FilterTime_before(ctx, field)
			case "after":
				return ec.fieldContext_FilterTime_after(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo_typeTwoBooleanFiltered(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoBooleanFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterBoolean)
	fc.Result = res
	return ec.marshalOFilterBoolean2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterBoolean(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo_typeTwoBooleanFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterBoolean_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterBoolean_eq(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterBoolean", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo_typeTwoSliceWithTypeTwos(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoSliceWithTypeTwos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NestedFilterTypeTwo)
	fc.Result = res
	return ec.marshalONestedFilterTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo_typeTwoSliceWithTypeTwos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeTwo__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeTwo__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeTwo__not(ctx, field)
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo_typeTwoWithTypeThree(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo_typeTwoWithTypeThree(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoWithTypeThree, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NestedFilterTypeThree)
	fc.Result = res
	return ec.marshalONestedFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo_typeTwoWithTypeThree(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx context.Context, field graphql.CollectedField, obj *FilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoWithTypeThreeNotMandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NestedFilterTypeThree)
	fc.Result = res
	return ec.marshalONestedFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FilterTypeTwo_typeTwoWithTypeThreeNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeThree__and(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeThree__and(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.And, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NestedFilterTypeThree)
	fc.Result = res
	return ec.marshalONestedFilterTypeThree2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeThree__and(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeThree__or(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeThree__or(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Or, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NestedFilterTypeThree)
	fc.Result = res
	return ec.marshalONestedFilterTypeThree2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeThree__or(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeThree__not(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeThree__not(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Not, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NestedFilterTypeThree)
	fc.Result = res
	return ec.marshalONestedFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeThree__not(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeStringFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterString)
	fc.Result = res
	return ec.marshalOFilterString2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeThree_typeThreeStringFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterString_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterString_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterString_neq(ctx, field)
			case "like":
				return ec.fieldContext_FilterString_like(ctx, field)
			case "nlike":
				return ec.fieldContext_FilterString_nlike(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterString", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeNumberFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterNumber)
	fc.Result = res
	return ec.marshalOFilterNumber2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterNumber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeThree_typeThreeNumberFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterNumber_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterNumber_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterNumber_neq(ctx, field)
			case "gt":
				return ec.fieldContext_FilterNumber_gt(ctx, field)
			case "lt":
				return ec.fieldContext_FilterNumber_lt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterNumber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeTimeFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterTime)
	fc.Result = res
	return ec.marshalOFilterTime2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeThree_typeThreeTimeFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterTime_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterTime_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterTime_neq(ctx, field)
			case "before":
				return ec.fieldContext_FilterTime_before(ctx, field)
			case "after":
				return ec.fieldContext_FilterTime_after(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeThree_typeThreeBooleanFiltered(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeThree_typeThreeBooleanFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeBooleanFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterBoolean)
	fc.Result = res
	return ec.marshalOFilterBoolean2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterBoolean(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeThree_typeThreeBooleanFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterBoolean_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterBoolean_eq(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterBoolean", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo__and(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo__and(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.And, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NestedFilterTypeTwo)
	fc.Result = res
	return ec.marshalONestedFilterTypeTwo2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo__and(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeTwo__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeTwo__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeTwo__not(ctx, field)
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo__or(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo__or(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Or, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*NestedFilterTypeTwo)
	fc.Result = res
	return ec.marshalONestedFilterTypeTwo2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo__or(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeTwo__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeTwo__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeTwo__not(ctx, field)
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo__not(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo__not(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Not, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NestedFilterTypeTwo)
	fc.Result = res
	return ec.marshalONestedFilterTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo__not(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeTwo__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeTwo__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeTwo__not(ctx, field)
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo_typeTwoStringFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoStringFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterString)
	fc.Result = res
	return ec.marshalOFilterString2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo_typeTwoStringFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterString_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterString_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterString_neq(ctx, field)
			case "like":
				return ec.fieldContext_FilterString_like(ctx, field)
			case "nlike":
				return ec.fieldContext_FilterString_nlike(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterString", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo_typeTwoNumberFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoNumberFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterNumber)
	fc.Result = res
	return ec.marshalOFilterNumber2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterNumber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo_typeTwoNumberFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterNumber_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterNumber_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterNumber_neq(ctx, field)
			case "gt":
				return ec.fieldContext_FilterNumber_gt(ctx, field)
			case "lt":
				return ec.fieldContext_FilterNumber_lt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterNumber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo_typeTwoTimeFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoTimeFieldFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterTime)
	fc.Result = res
	return ec.marshalOFilterTime2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo_typeTwoTimeFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterTime_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterTime_eq(ctx, field)
			case "neq":
				return ec.fieldContext_FilterTime_neq(ctx, field)
			case "before":
				return ec.fieldContext_FilterTime_before(ctx, field)
			case "after":
				return ec.fieldContext_FilterTime_after(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo_typeTwoBooleanFiltered(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoBooleanFiltered, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*FilterBoolean)
	fc.Result = res
	return ec.marshalOFilterBoolean2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterBoolean(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo_typeTwoBooleanFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_FilterBoolean_exists(ctx, field)
			case "eq":
				return ec.fieldContext_FilterBoolean_eq(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FilterBoolean", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoSliceWithTypeTwos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NestedFilterTypeTwo)
	fc.Result = res
	return ec.marshalONestedFilterTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeTwo__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeTwo__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeTwo__not(ctx, field)
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo_typeTwoWithTypeThree(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThree(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoWithTypeThree, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NestedFilterTypeThree)
	fc.Result = res
	return ec.marshalONestedFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThree(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx context.Context, field graphql.CollectedField, obj *NestedFilterTypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoWithTypeThreeNotMandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*NestedFilterTypeThree)
	fc.Result = res
	return ec.marshalONestedFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NestedFilterTypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_and":
				return ec.fieldContext_NestedFilterTypeThree__and(ctx, field)
			case "_or":
				return ec.fieldContext_NestedFilterTypeThree__or(ctx, field)
			case "_not":
				return ec.fieldContext_NestedFilterTypeThree__not(ctx, field)
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_NestedFilterTypeThree_typeThreeBooleanFiltered(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NestedFilterTypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneStringFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneStringFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeOneStringFieldFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneStringFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneStringFieldFilteredNotMandatory(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneStringFieldFilteredNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeOneStringFieldFilteredNotMandatory, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneStringFieldFilteredNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneNumberFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneNumberFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeOneNumberFieldFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneNumberFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneNumberFieldFilteredNotMandatory(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneNumberFieldFilteredNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeOneNumberFieldFilteredNotMandatory, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneNumberFieldFilteredNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneTimeFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneTimeFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeOneTimeFieldFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneTimeFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneTimeFieldFilteredNotMandatory(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneTimeFieldFilteredNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeOneTimeFieldFilteredNotMandatory, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneTimeFieldFilteredNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneBooleanFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneBooleanFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeOneBooleanFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneBooleanFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneBooleanFilteredNotMandatory(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneBooleanFilteredNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeOneBooleanFilteredNotMandatory, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneBooleanFilteredNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneStringFieldWithNoFilter(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneStringFieldWithNoFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneStringFieldWithNoFilter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneStringFieldWithNoFilter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneNumberFieldWithNoFilter(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneNumberFieldWithNoFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneNumberFieldWithNoFilter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneNumberFieldWithNoFilter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneTimeFieldWithNoFilter(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneTimeFieldWithNoFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeOneTimeFieldWithNoFilter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneTimeFieldWithNoFilter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeOne_typeOneSliceWithTypeTwos(ctx context.Context, field graphql.CollectedField, obj *TypeOne) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeOne_typeOneSliceWithTypeTwos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeOneSliceWithTypeTwos, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*TypeTwo); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/ajnavarro/gqlfiltergen/testdata/out.TypeTwo`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TypeTwo)
	fc.Result = res
	return ec.marshalNTypeTwo2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeOne_typeOneSliceWithTypeTwos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeOne",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_TypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_TypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_TypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_TypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoStringFieldWithNoFilter":
				return ec.fieldContext_TypeTwo_typeTwoStringFieldWithNoFilter(ctx, field)
			case "typeTwoNumberFieldWithNoFilter":
				return ec.fieldContext_TypeTwo_typeTwoNumberFieldWithNoFilter(ctx, field)
			case "typeTwoTimeFieldWithNoFilter":
				return ec.fieldContext_TypeTwo_typeTwoTimeFieldWithNoFilter(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_TypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_TypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_TypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeThree_typeThreeStringFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeThree_typeThreeStringFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeThreeStringFieldFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeThree_typeThreeStringFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeThree_typeThreeNumberFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeThree_typeThreeNumberFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeThreeNumberFieldFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeThree_typeThreeNumberFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeThree_typeThreeTimeFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeThree_typeThreeTimeFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeThreeTimeFieldFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeThree_typeThreeTimeFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeThree_typeThreeBooleanFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeThree_typeThreeBooleanFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeThreeBooleanFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeThree_typeThreeBooleanFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeThree_typeThreeStringFieldWithNoFilter(ctx context.Context, field graphql.CollectedField, obj *TypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeThree_typeThreeStringFieldWithNoFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeStringFieldWithNoFilter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeThree_typeThreeStringFieldWithNoFilter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeThree_typeThreeNumberFieldWithNoFilter(ctx context.Context, field graphql.CollectedField, obj *TypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeThree_typeThreeNumberFieldWithNoFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeNumberFieldWithNoFilter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeThree_typeThreeNumberFieldWithNoFilter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeThree_typeThreeTimeFieldWithNoFilter(ctx context.Context, field graphql.CollectedField, obj *TypeThree) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeThree_typeThreeTimeFieldWithNoFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeThreeTimeFieldWithNoFilter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeThree_typeThreeTimeFieldWithNoFilter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeThree",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoStringFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoStringFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeTwoStringFieldFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoStringFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoNumberFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoNumberFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeTwoNumberFieldFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoNumberFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoTimeFieldFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoTimeFieldFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeTwoTimeFieldFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoTimeFieldFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoBooleanFiltered(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoBooleanFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeTwoBooleanFiltered, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoBooleanFiltered(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoStringFieldWithNoFilter(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoStringFieldWithNoFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoStringFieldWithNoFilter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoStringFieldWithNoFilter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoNumberFieldWithNoFilter(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoNumberFieldWithNoFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoNumberFieldWithNoFilter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoNumberFieldWithNoFilter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoTimeFieldWithNoFilter(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoTimeFieldWithNoFilter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeTwoTimeFieldWithNoFilter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoTimeFieldWithNoFilter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoSliceWithTypeTwos(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeTwoSliceWithTypeTwos, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*TypeTwo); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/ajnavarro/gqlfiltergen/testdata/out.TypeTwo`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TypeTwo)
	fc.Result = res
	return ec.marshalNTypeTwo2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐTypeTwo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoSliceWithTypeTwos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "typeTwoStringFieldFiltered":
				return ec.fieldContext_TypeTwo_typeTwoStringFieldFiltered(ctx, field)
			case "typeTwoNumberFieldFiltered":
				return ec.fieldContext_TypeTwo_typeTwoNumberFieldFiltered(ctx, field)
			case "typeTwoTimeFieldFiltered":
				return ec.fieldContext_TypeTwo_typeTwoTimeFieldFiltered(ctx, field)
			case "typeTwoBooleanFiltered":
				return ec.fieldContext_TypeTwo_typeTwoBooleanFiltered(ctx, field)
			case "typeTwoStringFieldWithNoFilter":
				return ec.fieldContext_TypeTwo_typeTwoStringFieldWithNoFilter(ctx, field)
			case "typeTwoNumberFieldWithNoFilter":
				return ec.fieldContext_TypeTwo_typeTwoNumberFieldWithNoFilter(ctx, field)
			case "typeTwoTimeFieldWithNoFilter":
				return ec.fieldContext_TypeTwo_typeTwoTimeFieldWithNoFilter(ctx, field)
			case "typeTwoSliceWithTypeTwos":
				return ec.fieldContext_TypeTwo_typeTwoSliceWithTypeTwos(ctx, field)
			case "typeTwoWithTypeThree":
				return ec.fieldContext_TypeTwo_typeTwoWithTypeThree(ctx, field)
			case "typeTwoWithTypeThreeNotMandatory":
				return ec.fieldContext_TypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypeTwo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoWithTypeThree(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoWithTypeThree(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeTwoWithTypeThree, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeThree); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ajnavarro/gqlfiltergen/testdata/out.TypeThree`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TypeThree)
	fc.Result = res
	return ec.marshalNTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoWithTypeThree(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_TypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_TypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_TypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_TypeThree_typeThreeBooleanFiltered(ctx, field)
			case "typeThreeStringFieldWithNoFilter":
				return ec.fieldContext_TypeThree_typeThreeStringFieldWithNoFilter(ctx, field)
			case "typeThreeNumberFieldWithNoFilter":
				return ec.fieldContext_TypeThree_typeThreeNumberFieldWithNoFilter(ctx, field)
			case "typeThreeTimeFieldWithNoFilter":
				return ec.fieldContext_TypeThree_typeThreeTimeFieldWithNoFilter(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TypeTwo_typeTwoWithTypeThreeNotMandatory(ctx context.Context, field graphql.CollectedField, obj *TypeTwo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeTwoWithTypeThreeNotMandatory, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				return nil, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*TypeThree); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/ajnavarro/gqlfiltergen/testdata/out.TypeThree`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TypeThree)
	fc.Result = res
	return ec.marshalOTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐTypeThree(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TypeTwo_typeTwoWithTypeThreeNotMandatory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TypeTwo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "typeThreeStringFieldFiltered":
				return ec.fieldContext_TypeThree_typeThreeStringFieldFiltered(ctx, field)
			case "typeThreeNumberFieldFiltered":
				return ec.fieldContext_TypeThree_typeThreeNumberFieldFiltered(ctx, field)
			case "typeThreeTimeFieldFiltered":
				return ec.fieldContext_TypeThree_typeThreeTimeFieldFiltered(ctx, field)
			case "typeThreeBooleanFiltered":
				return ec.fieldContext_TypeThree_typeThreeBooleanFiltered(ctx, field)
			case "typeThreeStringFieldWithNoFilter":
				return ec.fieldContext_TypeThree_typeThreeStringFieldWithNoFilter(ctx, field)
			case "typeThreeNumberFieldWithNoFilter":
				return ec.fieldContext_TypeThree_typeThreeNumberFieldWithNoFilter(ctx, field)
			case "typeThreeTimeFieldWithNoFilter":
				return ec.fieldContext_TypeThree_typeThreeTimeFieldWithNoFilter(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TypeThree", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var filterBooleanImplementors = []string{"FilterBoolean"}

func (ec *executionContext) _FilterBoolean(ctx context.Context, sel ast.SelectionSet, obj *FilterBoolean) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filterBooleanImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FilterBoolean")
		case "exists":
			out.Values[i] = ec._FilterBoolean_exists(ctx, field, obj)
		case "eq":
			out.Values[i] = ec._FilterBoolean_eq(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filterNumberImplementors = []string{"FilterNumber"}

func (ec *executionContext) _FilterNumber(ctx context.Context, sel ast.SelectionSet, obj *FilterNumber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filterNumberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FilterNumber")
		case "exists":
			out.Values[i] = ec._FilterNumber_exists(ctx, field, obj)
		case "eq":
			out.Values[i] = ec._FilterNumber_eq(ctx, field, obj)
		case "neq":
			out.Values[i] = ec._FilterNumber_neq(ctx, field, obj)
		case "gt":
			out.Values[i] = ec._FilterNumber_gt(ctx, field, obj)
		case "lt":
			out.Values[i] = ec._FilterNumber_lt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filterStringImplementors = []string{"FilterString"}

func (ec *executionContext) _FilterString(ctx context.Context, sel ast.SelectionSet, obj *FilterString) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filterStringImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FilterString")
		case "exists":
			out.Values[i] = ec._FilterString_exists(ctx, field, obj)
		case "eq":
			out.Values[i] = ec._FilterString_eq(ctx, field, obj)
		case "neq":
			out.Values[i] = ec._FilterString_neq(ctx, field, obj)
		case "like":
			out.Values[i] = ec._FilterString_like(ctx, field, obj)
		case "nlike":
			out.Values[i] = ec._FilterString_nlike(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filterTimeImplementors = []string{"FilterTime"}

func (ec *executionContext) _FilterTime(ctx context.Context, sel ast.SelectionSet, obj *FilterTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filterTimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FilterTime")
		case "exists":
			out.Values[i] = ec._FilterTime_exists(ctx, field, obj)
		case "eq":
			out.Values[i] = ec._FilterTime_eq(ctx, field, obj)
		case "neq":
			out.Values[i] = ec._FilterTime_neq(ctx, field, obj)
		case "before":
			out.Values[i] = ec._FilterTime_before(ctx, field, obj)
		case "after":
			out.Values[i] = ec._FilterTime_after(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filterTypeOneImplementors = []string{"FilterTypeOne"}

func (ec *executionContext) _FilterTypeOne(ctx context.Context, sel ast.SelectionSet, obj *FilterTypeOne) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filterTypeOneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FilterTypeOne")
		case "_and":
			out.Values[i] = ec._FilterTypeOne__and(ctx, field, obj)
		case "_or":
			out.Values[i] = ec._FilterTypeOne__or(ctx, field, obj)
		case "_not":
			out.Values[i] = ec._FilterTypeOne__not(ctx, field, obj)
		case "typeOneStringFieldFiltered":
			out.Values[i] = ec._FilterTypeOne_typeOneStringFieldFiltered(ctx, field, obj)
		case "typeOneStringFieldFilteredNotMandatory":
			out.Values[i] = ec._FilterTypeOne_typeOneStringFieldFilteredNotMandatory(ctx, field, obj)
		case "typeOneNumberFieldFiltered":
			out.Values[i] = ec._FilterTypeOne_typeOneNumberFieldFiltered(ctx, field, obj)
		case "typeOneNumberFieldFilteredNotMandatory":
			out.Values[i] = ec._FilterTypeOne_typeOneNumberFieldFilteredNotMandatory(ctx, field, obj)
		case "typeOneTimeFieldFiltered":
			out.Values[i] = ec._FilterTypeOne_typeOneTimeFieldFiltered(ctx, field, obj)
		case "typeOneTimeFieldFilteredNotMandatory":
			out.Values[i] = ec._FilterTypeOne_typeOneTimeFieldFilteredNotMandatory(ctx, field, obj)
		case "typeOneBooleanFiltered":
			out.Values[i] = ec._FilterTypeOne_typeOneBooleanFiltered(ctx, field, obj)
		case "typeOneBooleanFilteredNotMandatory":
			out.Values[i] = ec._FilterTypeOne_typeOneBooleanFilteredNotMandatory(ctx, field, obj)
		case "typeOneSliceWithTypeTwos":
			out.Values[i] = ec._FilterTypeOne_typeOneSliceWithTypeTwos(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filterTypeThreeImplementors = []string{"FilterTypeThree"}

func (ec *executionContext) _FilterTypeThree(ctx context.Context, sel ast.SelectionSet, obj *FilterTypeThree) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filterTypeThreeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FilterTypeThree")
		case "_and":
			out.Values[i] = ec._FilterTypeThree__and(ctx, field, obj)
		case "_or":
			out.Values[i] = ec._FilterTypeThree__or(ctx, field, obj)
		case "_not":
			out.Values[i] = ec._FilterTypeThree__not(ctx, field, obj)
		case "typeThreeStringFieldFiltered":
			out.Values[i] = ec._FilterTypeThree_typeThreeStringFieldFiltered(ctx, field, obj)
		case "typeThreeNumberFieldFiltered":
			out.Values[i] = ec._FilterTypeThree_typeThreeNumberFieldFiltered(ctx, field, obj)
		case "typeThreeTimeFieldFiltered":
			out.Values[i] = ec._FilterTypeThree_typeThreeTimeFieldFiltered(ctx, field, obj)
		case "typeThreeBooleanFiltered":
			out.Values[i] = ec._FilterTypeThree_typeThreeBooleanFiltered(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var filterTypeTwoImplementors = []string{"FilterTypeTwo"}

func (ec *executionContext) _FilterTypeTwo(ctx context.Context, sel ast.SelectionSet, obj *FilterTypeTwo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, filterTypeTwoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FilterTypeTwo")
		case "_and":
			out.Values[i] = ec._FilterTypeTwo__and(ctx, field, obj)
		case "_or":
			out.Values[i] = ec._FilterTypeTwo__or(ctx, field, obj)
		case "_not":
			out.Values[i] = ec._FilterTypeTwo__not(ctx, field, obj)
		case "typeTwoStringFieldFiltered":
			out.Values[i] = ec._FilterTypeTwo_typeTwoStringFieldFiltered(ctx, field, obj)
		case "typeTwoNumberFieldFiltered":
			out.Values[i] = ec._FilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field, obj)
		case "typeTwoTimeFieldFiltered":
			out.Values[i] = ec._FilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field, obj)
		case "typeTwoBooleanFiltered":
			out.Values[i] = ec._FilterTypeTwo_typeTwoBooleanFiltered(ctx, field, obj)
		case "typeTwoSliceWithTypeTwos":
			out.Values[i] = ec._FilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field, obj)
		case "typeTwoWithTypeThree":
			out.Values[i] = ec._FilterTypeTwo_typeTwoWithTypeThree(ctx, field, obj)
		case "typeTwoWithTypeThreeNotMandatory":
			out.Values[i] = ec._FilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nestedFilterTypeThreeImplementors = []string{"NestedFilterTypeThree"}

func (ec *executionContext) _NestedFilterTypeThree(ctx context.Context, sel ast.SelectionSet, obj *NestedFilterTypeThree) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nestedFilterTypeThreeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NestedFilterTypeThree")
		case "_and":
			out.Values[i] = ec._NestedFilterTypeThree__and(ctx, field, obj)
		case "_or":
			out.Values[i] = ec._NestedFilterTypeThree__or(ctx, field, obj)
		case "_not":
			out.Values[i] = ec._NestedFilterTypeThree__not(ctx, field, obj)
		case "typeThreeStringFieldFiltered":
			out.Values[i] = ec._NestedFilterTypeThree_typeThreeStringFieldFiltered(ctx, field, obj)
		case "typeThreeNumberFieldFiltered":
			out.Values[i] = ec._NestedFilterTypeThree_typeThreeNumberFieldFiltered(ctx, field, obj)
		case "typeThreeTimeFieldFiltered":
			out.Values[i] = ec._NestedFilterTypeThree_typeThreeTimeFieldFiltered(ctx, field, obj)
		case "typeThreeBooleanFiltered":
			out.Values[i] = ec._NestedFilterTypeThree_typeThreeBooleanFiltered(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nestedFilterTypeTwoImplementors = []string{"NestedFilterTypeTwo"}

func (ec *executionContext) _NestedFilterTypeTwo(ctx context.Context, sel ast.SelectionSet, obj *NestedFilterTypeTwo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nestedFilterTypeTwoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NestedFilterTypeTwo")
		case "_and":
			out.Values[i] = ec._NestedFilterTypeTwo__and(ctx, field, obj)
		case "_or":
			out.Values[i] = ec._NestedFilterTypeTwo__or(ctx, field, obj)
		case "_not":
			out.Values[i] = ec._NestedFilterTypeTwo__not(ctx, field, obj)
		case "typeTwoStringFieldFiltered":
			out.Values[i] = ec._NestedFilterTypeTwo_typeTwoStringFieldFiltered(ctx, field, obj)
		case "typeTwoNumberFieldFiltered":
			out.Values[i] = ec._NestedFilterTypeTwo_typeTwoNumberFieldFiltered(ctx, field, obj)
		case "typeTwoTimeFieldFiltered":
			out.Values[i] = ec._NestedFilterTypeTwo_typeTwoTimeFieldFiltered(ctx, field, obj)
		case "typeTwoBooleanFiltered":
			out.Values[i] = ec._NestedFilterTypeTwo_typeTwoBooleanFiltered(ctx, field, obj)
		case "typeTwoSliceWithTypeTwos":
			out.Values[i] = ec._NestedFilterTypeTwo_typeTwoSliceWithTypeTwos(ctx, field, obj)
		case "typeTwoWithTypeThree":
			out.Values[i] = ec._NestedFilterTypeTwo_typeTwoWithTypeThree(ctx, field, obj)
		case "typeTwoWithTypeThreeNotMandatory":
			out.Values[i] = ec._NestedFilterTypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var typeOneImplementors = []string{"TypeOne"}

func (ec *executionContext) _TypeOne(ctx context.Context, sel ast.SelectionSet, obj *TypeOne) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeOneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeOne")
		case "typeOneStringFieldFiltered":
			out.Values[i] = ec._TypeOne_typeOneStringFieldFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeOneStringFieldFilteredNotMandatory":
			out.Values[i] = ec._TypeOne_typeOneStringFieldFilteredNotMandatory(ctx, field, obj)
		case "typeOneNumberFieldFiltered":
			out.Values[i] = ec._TypeOne_typeOneNumberFieldFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeOneNumberFieldFilteredNotMandatory":
			out.Values[i] = ec._TypeOne_typeOneNumberFieldFilteredNotMandatory(ctx, field, obj)
		case "typeOneTimeFieldFiltered":
			out.Values[i] = ec._TypeOne_typeOneTimeFieldFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeOneTimeFieldFilteredNotMandatory":
			out.Values[i] = ec._TypeOne_typeOneTimeFieldFilteredNotMandatory(ctx, field, obj)
		case "typeOneBooleanFiltered":
			out.Values[i] = ec._TypeOne_typeOneBooleanFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeOneBooleanFilteredNotMandatory":
			out.Values[i] = ec._TypeOne_typeOneBooleanFilteredNotMandatory(ctx, field, obj)
		case "typeOneStringFieldWithNoFilter":
			out.Values[i] = ec._TypeOne_typeOneStringFieldWithNoFilter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeOneNumberFieldWithNoFilter":
			out.Values[i] = ec._TypeOne_typeOneNumberFieldWithNoFilter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeOneTimeFieldWithNoFilter":
			out.Values[i] = ec._TypeOne_typeOneTimeFieldWithNoFilter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeOneSliceWithTypeTwos":
			out.Values[i] = ec._TypeOne_typeOneSliceWithTypeTwos(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var typeThreeImplementors = []string{"TypeThree"}

func (ec *executionContext) _TypeThree(ctx context.Context, sel ast.SelectionSet, obj *TypeThree) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeThreeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeThree")
		case "typeThreeStringFieldFiltered":
			out.Values[i] = ec._TypeThree_typeThreeStringFieldFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeThreeNumberFieldFiltered":
			out.Values[i] = ec._TypeThree_typeThreeNumberFieldFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeThreeTimeFieldFiltered":
			out.Values[i] = ec._TypeThree_typeThreeTimeFieldFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeThreeBooleanFiltered":
			out.Values[i] = ec._TypeThree_typeThreeBooleanFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeThreeStringFieldWithNoFilter":
			out.Values[i] = ec._TypeThree_typeThreeStringFieldWithNoFilter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeThreeNumberFieldWithNoFilter":
			out.Values[i] = ec._TypeThree_typeThreeNumberFieldWithNoFilter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeThreeTimeFieldWithNoFilter":
			out.Values[i] = ec._TypeThree_typeThreeTimeFieldWithNoFilter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var typeTwoImplementors = []string{"TypeTwo"}

func (ec *executionContext) _TypeTwo(ctx context.Context, sel ast.SelectionSet, obj *TypeTwo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeTwoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeTwo")
		case "typeTwoStringFieldFiltered":
			out.Values[i] = ec._TypeTwo_typeTwoStringFieldFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeTwoNumberFieldFiltered":
			out.Values[i] = ec._TypeTwo_typeTwoNumberFieldFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeTwoTimeFieldFiltered":
			out.Values[i] = ec._TypeTwo_typeTwoTimeFieldFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeTwoBooleanFiltered":
			out.Values[i] = ec._TypeTwo_typeTwoBooleanFiltered(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeTwoStringFieldWithNoFilter":
			out.Values[i] = ec._TypeTwo_typeTwoStringFieldWithNoFilter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeTwoNumberFieldWithNoFilter":
			out.Values[i] = ec._TypeTwo_typeTwoNumberFieldWithNoFilter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeTwoTimeFieldWithNoFilter":
			out.Values[i] = ec._TypeTwo_typeTwoTimeFieldWithNoFilter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeTwoSliceWithTypeTwos":
			out.Values[i] = ec._TypeTwo_typeTwoSliceWithTypeTwos(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeTwoWithTypeThree":
			out.Values[i] = ec._TypeTwo_typeTwoWithTypeThree(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "typeTwoWithTypeThreeNotMandatory":
			out.Values[i] = ec._TypeTwo_typeTwoWithTypeThreeNotMandatory(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐTypeThree(ctx context.Context, sel ast.SelectionSet, v *TypeThree) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TypeThree(ctx, sel, v)
}

func (ec *executionContext) marshalNTypeTwo2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐTypeTwo(ctx context.Context, sel ast.SelectionSet, v []*TypeTwo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐTypeTwo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOFilterBoolean2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterBoolean(ctx context.Context, sel ast.SelectionSet, v *FilterBoolean) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FilterBoolean(ctx, sel, v)
}

func (ec *executionContext) marshalOFilterNumber2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterNumber(ctx context.Context, sel ast.SelectionSet, v *FilterNumber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FilterNumber(ctx, sel, v)
}

func (ec *executionContext) marshalOFilterString2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterString(ctx context.Context, sel ast.SelectionSet, v *FilterString) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FilterString(ctx, sel, v)
}

func (ec *executionContext) marshalOFilterTime2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTime(ctx context.Context, sel ast.SelectionSet, v *FilterTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FilterTime(ctx, sel, v)
}

func (ec *executionContext) marshalOFilterTypeOne2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeOne(ctx context.Context, sel ast.SelectionSet, v []*FilterTypeOne) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFilterTypeOne2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeOne(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOFilterTypeOne2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeOne(ctx context.Context, sel ast.SelectionSet, v *FilterTypeOne) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FilterTypeOne(ctx, sel, v)
}

func (ec *executionContext) marshalOFilterTypeThree2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeThree(ctx context.Context, sel ast.SelectionSet, v []*FilterTypeThree) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeThree(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeThree(ctx context.Context, sel ast.SelectionSet, v *FilterTypeThree) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FilterTypeThree(ctx, sel, v)
}

func (ec *executionContext) marshalOFilterTypeTwo2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeTwo(ctx context.Context, sel ast.SelectionSet, v []*FilterTypeTwo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFilterTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeTwo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOFilterTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐFilterTypeTwo(ctx context.Context, sel ast.SelectionSet, v *FilterTypeTwo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FilterTypeTwo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalONestedFilterTypeThree2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx context.Context, sel ast.SelectionSet, v []*NestedFilterTypeThree) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONestedFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalONestedFilterTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeThree(ctx context.Context, sel ast.SelectionSet, v *NestedFilterTypeThree) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NestedFilterTypeThree(ctx, sel, v)
}

func (ec *executionContext) marshalONestedFilterTypeTwo2ᚕᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeTwo(ctx context.Context, sel ast.SelectionSet, v []*NestedFilterTypeTwo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONestedFilterTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeTwo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalONestedFilterTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐNestedFilterTypeTwo(ctx context.Context, sel ast.SelectionSet, v *NestedFilterTypeTwo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NestedFilterTypeTwo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTypeThree2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐTypeThree(ctx context.Context, sel ast.SelectionSet, v *TypeThree) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypeThree(ctx, sel, v)
}

func (ec *executionContext) marshalOTypeTwo2ᚖgithubᚗcomᚋajnavarroᚋgqlfiltergenᚋtestdataᚋoutᚐTypeTwo(ctx context.Context, sel ast.SelectionSet, v *TypeTwo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypeTwo(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
