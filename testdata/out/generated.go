// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package out

import (
	"time"
)

// Filter type for boolean fields. All added filters here are processed as AND operators.
type FilterBoolean struct {
	// Filter a boolean field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a boolean field checking if it is equals to the specified value.
	Eq *bool `json:"eq,omitempty"`
}

// filter for ExternalType objects
type FilterExternalType struct {
	// logical operator for ExternalType that will combine two or more conditions, returning true if all of them are true.
	And []*FilterExternalType `json:"_and,omitempty"`
	// logical operator for ExternalType that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterExternalType `json:"_or,omitempty"`
	// logical operator for ExternalType that will reverse conditions.
	Not *FilterExternalType `json:"_not,omitempty"`
	// filter for numberOne field.
	NumberOne *FilterNumber `json:"numberOne,omitempty"`
	// filter for numberTwo field.
	NumberTwo *FilterNumber `json:"numberTwo,omitempty"`
	// filter for numberThree field.
	NumberThree *FilterNumber `json:"numberThree,omitempty"`
	// filter for numberFour field.
	NumberFour *FilterNumber `json:"numberFour,omitempty"`
	// filter for numberFive field.
	NumberFive *FilterNumber `json:"numberFive,omitempty"`
	// filter for numberList field.
	NumberList *FilterNumber `json:"numberList,omitempty"`
	// filter for typeOne field.
	TypeOne *NestedFilterTypeOne `json:"typeOne,omitempty"`
}

// Filter type for number fields. All added filters here are processed as AND operators.
type FilterNumber struct {
	// Filter a number field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a number field checking if it is equals to the specified value.
	Eq *int `json:"eq,omitempty"`
	// Filter a number field checking if it is NOT equals to the specified value.
	Neq *int `json:"neq,omitempty"`
	// Filter a number field checking if it is greater than the specified value.
	Gt *int `json:"gt,omitempty"`
	// Filter a number field checking if it is less than the specified value.
	Lt *int `json:"lt,omitempty"`
}

// Filter type for string fields. It contains a variety of filter types for string types. All added filters here are processed as AND operators.
type FilterString struct {
	// Filter a string field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a string field checking if it is equals to the specified value.
	Eq *string `json:"eq,omitempty"`
	// Filter a string field checking if it is NOT equals to the specified value.
	Neq *string `json:"neq,omitempty"`
	// Filter a string field checking if it is like the specified value. You can use standard Go RegEx expressions here.
	Like *string `json:"like,omitempty"`
	// Filter a string field checking if it is NOT like the specified value. You can use standard Go RegEx expressions here.
	Nlike *string `json:"nlike,omitempty"`
}

// Filter type for time fields. All added filters here are processed as AND operators.
type FilterTime struct {
	// Filter a time field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a time field checking if it is equals to the specified value.
	Eq *time.Time `json:"eq,omitempty"`
	// Filter a time field checking if it is NOT equals to the specified value.
	Neq *time.Time `json:"neq,omitempty"`
	// Filter a time field checking if it is before than the specified value.
	Before *time.Time `json:"before,omitempty"`
	// Filter a time field checking if it is after the specified value.
	After *time.Time `json:"after,omitempty"`
}

// filter for TypeOne objects
type FilterTypeOne struct {
	// logical operator for TypeOne that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTypeOne `json:"_and,omitempty"`
	// logical operator for TypeOne that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTypeOne `json:"_or,omitempty"`
	// logical operator for TypeOne that will reverse conditions.
	Not *FilterTypeOne `json:"_not,omitempty"`
	// filter for typeOneStringFieldFiltered field.
	TypeOneStringFieldFiltered *FilterString `json:"typeOneStringFieldFiltered,omitempty"`
	// filter for typeOneStringFieldFilteredNotMandatory field.
	TypeOneStringFieldFilteredNotMandatory *FilterString `json:"typeOneStringFieldFilteredNotMandatory,omitempty"`
	// filter for typeOneNumberFieldFiltered field.
	TypeOneNumberFieldFiltered *FilterNumber `json:"typeOneNumberFieldFiltered,omitempty"`
	// filter for typeOneNumberFieldFilteredNotMandatory field.
	TypeOneNumberFieldFilteredNotMandatory *FilterNumber `json:"typeOneNumberFieldFilteredNotMandatory,omitempty"`
	// filter for typeOneTimeFieldFiltered field.
	TypeOneTimeFieldFiltered *FilterTime `json:"typeOneTimeFieldFiltered,omitempty"`
	// filter for typeOneTimeFieldFilteredNotMandatory field.
	TypeOneTimeFieldFilteredNotMandatory *FilterTime `json:"typeOneTimeFieldFilteredNotMandatory,omitempty"`
	// filter for typeOneBooleanFiltered field.
	TypeOneBooleanFiltered *FilterBoolean `json:"typeOneBooleanFiltered,omitempty"`
	// filter for typeOneBooleanFilteredNotMandatory field.
	TypeOneBooleanFilteredNotMandatory *FilterBoolean `json:"typeOneBooleanFilteredNotMandatory,omitempty"`
	// filter for typeOneSliceWithTypeTwos field.
	TypeOneSliceWithTypeTwos *NestedFilterTypeTwo `json:"typeOneSliceWithTypeTwos,omitempty"`
}

// filter for TypeThree objects
type FilterTypeThree struct {
	// logical operator for TypeThree that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTypeThree `json:"_and,omitempty"`
	// logical operator for TypeThree that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTypeThree `json:"_or,omitempty"`
	// logical operator for TypeThree that will reverse conditions.
	Not *FilterTypeThree `json:"_not,omitempty"`
	// filter for typeThreeStringFieldFiltered field.
	TypeThreeStringFieldFiltered *FilterString `json:"typeThreeStringFieldFiltered,omitempty"`
	// filter for typeThreeNumberFieldFiltered field.
	TypeThreeNumberFieldFiltered *FilterNumber `json:"typeThreeNumberFieldFiltered,omitempty"`
	// filter for typeThreeTimeFieldFiltered field.
	TypeThreeTimeFieldFiltered *FilterTime `json:"typeThreeTimeFieldFiltered,omitempty"`
	// filter for typeThreeBooleanFiltered field.
	TypeThreeBooleanFiltered *FilterBoolean `json:"typeThreeBooleanFiltered,omitempty"`
}

// filter for TypeTwo objects
type FilterTypeTwo struct {
	// logical operator for TypeTwo that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTypeTwo `json:"_and,omitempty"`
	// logical operator for TypeTwo that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTypeTwo `json:"_or,omitempty"`
	// logical operator for TypeTwo that will reverse conditions.
	Not *FilterTypeTwo `json:"_not,omitempty"`
	// filter for typeTwoStringFieldFiltered field.
	TypeTwoStringFieldFiltered *FilterString `json:"typeTwoStringFieldFiltered,omitempty"`
	// filter for typeTwoNumberFieldFiltered field.
	TypeTwoNumberFieldFiltered *FilterNumber `json:"typeTwoNumberFieldFiltered,omitempty"`
	// filter for typeTwoTimeFieldFiltered field.
	TypeTwoTimeFieldFiltered *FilterTime `json:"typeTwoTimeFieldFiltered,omitempty"`
	// filter for typeTwoBooleanFiltered field.
	TypeTwoBooleanFiltered *FilterBoolean `json:"typeTwoBooleanFiltered,omitempty"`
	// filter for typeTwoSliceWithTypeTwos field.
	TypeTwoSliceWithTypeTwos *NestedFilterTypeTwo `json:"typeTwoSliceWithTypeTwos,omitempty"`
	// filter for typeTwoWithTypeThree field.
	TypeTwoWithTypeThree *NestedFilterTypeThree `json:"typeTwoWithTypeThree,omitempty"`
	// filter for typeTwoWithTypeThreeNotMandatory field.
	TypeTwoWithTypeThreeNotMandatory *NestedFilterTypeThree `json:"typeTwoWithTypeThreeNotMandatory,omitempty"`
}

// filter for TypeOne objects
type NestedFilterTypeOne struct {
	// logical operator for TypeOne that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterTypeOne `json:"_and,omitempty"`
	// logical operator for TypeOne that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterTypeOne `json:"_or,omitempty"`
	// logical operator for TypeOne that will reverse conditions.
	Not *NestedFilterTypeOne `json:"_not,omitempty"`
	// filter for typeOneStringFieldFiltered field.
	TypeOneStringFieldFiltered *FilterString `json:"typeOneStringFieldFiltered,omitempty"`
	// filter for typeOneStringFieldFilteredNotMandatory field.
	TypeOneStringFieldFilteredNotMandatory *FilterString `json:"typeOneStringFieldFilteredNotMandatory,omitempty"`
	// filter for typeOneNumberFieldFiltered field.
	TypeOneNumberFieldFiltered *FilterNumber `json:"typeOneNumberFieldFiltered,omitempty"`
	// filter for typeOneNumberFieldFilteredNotMandatory field.
	TypeOneNumberFieldFilteredNotMandatory *FilterNumber `json:"typeOneNumberFieldFilteredNotMandatory,omitempty"`
	// filter for typeOneTimeFieldFiltered field.
	TypeOneTimeFieldFiltered *FilterTime `json:"typeOneTimeFieldFiltered,omitempty"`
	// filter for typeOneTimeFieldFilteredNotMandatory field.
	TypeOneTimeFieldFilteredNotMandatory *FilterTime `json:"typeOneTimeFieldFilteredNotMandatory,omitempty"`
	// filter for typeOneBooleanFiltered field.
	TypeOneBooleanFiltered *FilterBoolean `json:"typeOneBooleanFiltered,omitempty"`
	// filter for typeOneBooleanFilteredNotMandatory field.
	TypeOneBooleanFilteredNotMandatory *FilterBoolean `json:"typeOneBooleanFilteredNotMandatory,omitempty"`
	// filter for typeOneSliceWithTypeTwos field.
	TypeOneSliceWithTypeTwos *NestedFilterTypeTwo `json:"typeOneSliceWithTypeTwos,omitempty"`
}

// filter for TypeThree objects
type NestedFilterTypeThree struct {
	// logical operator for TypeThree that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterTypeThree `json:"_and,omitempty"`
	// logical operator for TypeThree that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterTypeThree `json:"_or,omitempty"`
	// logical operator for TypeThree that will reverse conditions.
	Not *NestedFilterTypeThree `json:"_not,omitempty"`
	// filter for typeThreeStringFieldFiltered field.
	TypeThreeStringFieldFiltered *FilterString `json:"typeThreeStringFieldFiltered,omitempty"`
	// filter for typeThreeNumberFieldFiltered field.
	TypeThreeNumberFieldFiltered *FilterNumber `json:"typeThreeNumberFieldFiltered,omitempty"`
	// filter for typeThreeTimeFieldFiltered field.
	TypeThreeTimeFieldFiltered *FilterTime `json:"typeThreeTimeFieldFiltered,omitempty"`
	// filter for typeThreeBooleanFiltered field.
	TypeThreeBooleanFiltered *FilterBoolean `json:"typeThreeBooleanFiltered,omitempty"`
}

// filter for TypeTwo objects
type NestedFilterTypeTwo struct {
	// logical operator for TypeTwo that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterTypeTwo `json:"_and,omitempty"`
	// logical operator for TypeTwo that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterTypeTwo `json:"_or,omitempty"`
	// logical operator for TypeTwo that will reverse conditions.
	Not *NestedFilterTypeTwo `json:"_not,omitempty"`
	// filter for typeTwoStringFieldFiltered field.
	TypeTwoStringFieldFiltered *FilterString `json:"typeTwoStringFieldFiltered,omitempty"`
	// filter for typeTwoNumberFieldFiltered field.
	TypeTwoNumberFieldFiltered *FilterNumber `json:"typeTwoNumberFieldFiltered,omitempty"`
	// filter for typeTwoTimeFieldFiltered field.
	TypeTwoTimeFieldFiltered *FilterTime `json:"typeTwoTimeFieldFiltered,omitempty"`
	// filter for typeTwoBooleanFiltered field.
	TypeTwoBooleanFiltered *FilterBoolean `json:"typeTwoBooleanFiltered,omitempty"`
	// filter for typeTwoSliceWithTypeTwos field.
	TypeTwoSliceWithTypeTwos *NestedFilterTypeTwo `json:"typeTwoSliceWithTypeTwos,omitempty"`
	// filter for typeTwoWithTypeThree field.
	TypeTwoWithTypeThree *NestedFilterTypeThree `json:"typeTwoWithTypeThree,omitempty"`
	// filter for typeTwoWithTypeThreeNotMandatory field.
	TypeTwoWithTypeThreeNotMandatory *NestedFilterTypeThree `json:"typeTwoWithTypeThreeNotMandatory,omitempty"`
}

type Query struct {
}

type TypeOne struct {
	TypeOneStringFieldFiltered             string     `json:"typeOneStringFieldFiltered"`
	TypeOneStringFieldFilteredNotMandatory *string    `json:"typeOneStringFieldFilteredNotMandatory,omitempty"`
	TypeOneNumberFieldFiltered             int        `json:"typeOneNumberFieldFiltered"`
	TypeOneNumberFieldFilteredNotMandatory *int       `json:"typeOneNumberFieldFilteredNotMandatory,omitempty"`
	TypeOneTimeFieldFiltered               time.Time  `json:"typeOneTimeFieldFiltered"`
	TypeOneTimeFieldFilteredNotMandatory   *time.Time `json:"typeOneTimeFieldFilteredNotMandatory,omitempty"`
	TypeOneBooleanFiltered                 bool       `json:"typeOneBooleanFiltered"`
	TypeOneBooleanFilteredNotMandatory     *bool      `json:"typeOneBooleanFilteredNotMandatory,omitempty"`
	TypeOneStringFieldWithNoFilter         string     `json:"typeOneStringFieldWithNoFilter"`
	TypeOneNumberFieldWithNoFilter         int        `json:"typeOneNumberFieldWithNoFilter"`
	TypeOneTimeFieldWithNoFilter           time.Time  `json:"typeOneTimeFieldWithNoFilter"`
	TypeOneSliceWithTypeTwos               []*TypeTwo `json:"typeOneSliceWithTypeTwos"`
}

type TypeThree struct {
	TypeThreeStringFieldFiltered     string    `json:"typeThreeStringFieldFiltered"`
	TypeThreeNumberFieldFiltered     int       `json:"typeThreeNumberFieldFiltered"`
	TypeThreeTimeFieldFiltered       time.Time `json:"typeThreeTimeFieldFiltered"`
	TypeThreeBooleanFiltered         bool      `json:"typeThreeBooleanFiltered"`
	TypeThreeStringFieldWithNoFilter string    `json:"typeThreeStringFieldWithNoFilter"`
	TypeThreeNumberFieldWithNoFilter int       `json:"typeThreeNumberFieldWithNoFilter"`
	TypeThreeTimeFieldWithNoFilter   time.Time `json:"typeThreeTimeFieldWithNoFilter"`
}

type TypeTwo struct {
	TypeTwoStringFieldFiltered       string     `json:"typeTwoStringFieldFiltered"`
	TypeTwoNumberFieldFiltered       int        `json:"typeTwoNumberFieldFiltered"`
	TypeTwoTimeFieldFiltered         time.Time  `json:"typeTwoTimeFieldFiltered"`
	TypeTwoBooleanFiltered           bool       `json:"typeTwoBooleanFiltered"`
	TypeTwoStringFieldWithNoFilter   string     `json:"typeTwoStringFieldWithNoFilter"`
	TypeTwoNumberFieldWithNoFilter   int        `json:"typeTwoNumberFieldWithNoFilter"`
	TypeTwoTimeFieldWithNoFilter     time.Time  `json:"typeTwoTimeFieldWithNoFilter"`
	TypeTwoSliceWithTypeTwos         []*TypeTwo `json:"typeTwoSliceWithTypeTwos"`
	TypeTwoWithTypeThree             *TypeThree `json:"typeTwoWithTypeThree"`
	TypeTwoWithTypeThreeNotMandatory *TypeThree `json:"typeTwoWithTypeThreeNotMandatory,omitempty"`
}
