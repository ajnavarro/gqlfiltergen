// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package out

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// Filter type for boolean fields. All added filters here are processed as AND operators.
type FilterBoolean struct {
	// Filter a boolean field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a boolean field checking if it is equals to the specified value.
	Eq *bool `json:"eq,omitempty"`
}

// filter for ExternalType objects
type FilterExternalType struct {
	// logical operator for ExternalType that will combine two or more conditions, returning true if all of them are true.
	And []*FilterExternalType `json:"_and,omitempty"`
	// logical operator for ExternalType that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterExternalType `json:"_or,omitempty"`
	// logical operator for ExternalType that will reverse conditions.
	Not *FilterExternalType `json:"_not,omitempty"`
	// filter for number_one field.
	NumberOne *FilterNumber `json:"number_one,omitempty"`
	// filter for number_two field.
	NumberTwo *FilterNumber `json:"number_two,omitempty"`
	// filter for number_three field.
	NumberThree *FilterNumber `json:"number_three,omitempty"`
	// filter for number_four field.
	NumberFour *FilterNumber `json:"number_four,omitempty"`
	// filter for number_five field.
	NumberFive *FilterNumber `json:"number_five,omitempty"`
	// filter for number_list field.
	NumberList *FilterNumber `json:"number_list,omitempty"`
	// filter for type_one field.
	TypeOne *NestedFilterTypeOne `json:"type_one,omitempty"`
}

// Filter type for number fields. All added filters here are processed as AND operators.
type FilterNumber struct {
	// Filter a number field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a number field checking if it is equals to the specified value.
	Eq *int `json:"eq,omitempty"`
	// Filter a number field checking if it is NOT equals to the specified value.
	Neq *int `json:"neq,omitempty"`
	// Filter a number field checking if it is greater than the specified value.
	Gt *int `json:"gt,omitempty"`
	// Filter a number field checking if it is less than the specified value.
	Lt *int `json:"lt,omitempty"`
}

// Filter type for string fields. It contains a variety of filter types for string types. All added filters here are processed as AND operators.
type FilterString struct {
	// Filter a string field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a string field checking if it is equals to the specified value.
	Eq *string `json:"eq,omitempty"`
	// Filter a string field checking if it is NOT equals to the specified value.
	Neq *string `json:"neq,omitempty"`
	// Filter a string field checking if it is like the specified value. You can use standard Go RegEx expressions here.
	Like *string `json:"like,omitempty"`
	// Filter a string field checking if it is NOT like the specified value. You can use standard Go RegEx expressions here.
	Nlike *string `json:"nlike,omitempty"`
}

// Filter type for time fields. All added filters here are processed as AND operators.
type FilterTime struct {
	// Filter a time field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a time field checking if it is equals to the specified value.
	Eq *time.Time `json:"eq,omitempty"`
	// Filter a time field checking if it is NOT equals to the specified value.
	Neq *time.Time `json:"neq,omitempty"`
	// Filter a time field checking if it is before than the specified value.
	Before *time.Time `json:"before,omitempty"`
	// Filter a time field checking if it is after the specified value.
	After *time.Time `json:"after,omitempty"`
}

// filter for TypeOne objects
type FilterTypeOne struct {
	// logical operator for TypeOne that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTypeOne `json:"_and,omitempty"`
	// logical operator for TypeOne that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTypeOne `json:"_or,omitempty"`
	// logical operator for TypeOne that will reverse conditions.
	Not *FilterTypeOne `json:"_not,omitempty"`
	// filter for type_one_string_field_filtered field.
	TypeOneStringFieldFiltered *FilterString `json:"type_one_string_field_filtered,omitempty"`
	// filter for type_one_string_field_filtered_not_mandatory field.
	TypeOneStringFieldFilteredNotMandatory *FilterString `json:"type_one_string_field_filtered_not_mandatory,omitempty"`
	// filter for type_one_number_field_filtered field.
	TypeOneNumberFieldFiltered *FilterNumber `json:"type_one_number_field_filtered,omitempty"`
	// filter for type_one_number_field_filtered_not_mandatory field.
	TypeOneNumberFieldFilteredNotMandatory *FilterNumber `json:"type_one_number_field_filtered_not_mandatory,omitempty"`
	// filter for type_one_time_field_filtered field.
	TypeOneTimeFieldFiltered *FilterTime `json:"type_one_time_field_filtered,omitempty"`
	// filter for type_one_time_field_filtered_not_mandatory field.
	TypeOneTimeFieldFilteredNotMandatory *FilterTime `json:"type_one_time_field_filtered_not_mandatory,omitempty"`
	// filter for type_one_boolean_field_filtered field.
	TypeOneBooleanFieldFiltered *FilterBoolean `json:"type_one_boolean_field_filtered,omitempty"`
	// filter for type_one_boolean_field_filtered_not_mandatory field.
	TypeOneBooleanFieldFilteredNotMandatory *FilterBoolean `json:"type_one_boolean_field_filtered_not_mandatory,omitempty"`
	// filter for type_one_slice_with_type_twos field.
	TypeOneSliceWithTypeTwos *NestedFilterTypeTwo `json:"type_one_slice_with_type_twos,omitempty"`
}

// filter for TypeThree objects
type FilterTypeThree struct {
	// logical operator for TypeThree that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTypeThree `json:"_and,omitempty"`
	// logical operator for TypeThree that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTypeThree `json:"_or,omitempty"`
	// logical operator for TypeThree that will reverse conditions.
	Not *FilterTypeThree `json:"_not,omitempty"`
	// filter for type_three_string_field_filtered field.
	TypeThreeStringFieldFiltered *FilterString `json:"type_three_string_field_filtered,omitempty"`
	// filter for type_three_number_field_filtered field.
	TypeThreeNumberFieldFiltered *FilterNumber `json:"type_three_number_field_filtered,omitempty"`
	// filter for type_three_time_field_filtered field.
	TypeThreeTimeFieldFiltered *FilterTime `json:"type_three_time_field_filtered,omitempty"`
	// filter for type_three_boolean_field_filtered field.
	TypeThreeBooleanFieldFiltered *FilterBoolean `json:"type_three_boolean_field_filtered,omitempty"`
}

// filter for TypeTwo objects
type FilterTypeTwo struct {
	// logical operator for TypeTwo that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTypeTwo `json:"_and,omitempty"`
	// logical operator for TypeTwo that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTypeTwo `json:"_or,omitempty"`
	// logical operator for TypeTwo that will reverse conditions.
	Not *FilterTypeTwo `json:"_not,omitempty"`
	// filter for type_two_string_field_filtered field.
	TypeTwoStringFieldFiltered *FilterString `json:"type_two_string_field_filtered,omitempty"`
	// filter for type_two_number_field_filtered field.
	TypeTwoNumberFieldFiltered *FilterNumber `json:"type_two_number_field_filtered,omitempty"`
	// filter for type_two_time_field_filtered field.
	TypeTwoTimeFieldFiltered *FilterTime `json:"type_two_time_field_filtered,omitempty"`
	// filter for type_two_boolean_field_filtered field.
	TypeTwoBooleanFieldFiltered *FilterBoolean `json:"type_two_boolean_field_filtered,omitempty"`
	// filter for type_two_slice_with_type_twos field.
	TypeTwoSliceWithTypeTwos *NestedFilterTypeTwo `json:"type_two_slice_with_type_twos,omitempty"`
	// filter for type_two_with_type_three field.
	TypeTwoWithTypeThree *NestedFilterTypeThree `json:"type_two_with_type_three,omitempty"`
	// filter for type_two_with_type_three_not_mandatory field.
	TypeTwoWithTypeThreeNotMandatory *NestedFilterTypeThree `json:"type_two_with_type_three_not_mandatory,omitempty"`
}

type InputOne struct {
	TypeTwoStringFieldFiltered     string    `json:"type_two_string_field_filtered"`
	TypeTwoNumberFieldFiltered     int       `json:"type_two_number_field_filtered"`
	TypeTwoTimeFieldFiltered       time.Time `json:"type_two_time_field_filtered"`
	TypeTwoBooleanFieldFiltered    bool      `json:"type_two_boolean_field_filtered"`
	TypeTwoStringFieldWithNoFilter string    `json:"type_twoString_field_with_no_filter"`
	TypeTwoNumberFieldWithNoFilter int       `json:"type_twoNumber_field_with_no_filter"`
	TypeTwoTimeFieldWithNoFilter   time.Time `json:"type_twoTime_field_with_no_filter"`
}

// filter for TypeOne objects
type NestedFilterTypeOne struct {
	// logical operator for TypeOne that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterTypeOne `json:"_and,omitempty"`
	// logical operator for TypeOne that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterTypeOne `json:"_or,omitempty"`
	// logical operator for TypeOne that will reverse conditions.
	Not *NestedFilterTypeOne `json:"_not,omitempty"`
	// filter for type_one_string_field_filtered field.
	TypeOneStringFieldFiltered *FilterString `json:"type_one_string_field_filtered,omitempty"`
	// filter for type_one_string_field_filtered_not_mandatory field.
	TypeOneStringFieldFilteredNotMandatory *FilterString `json:"type_one_string_field_filtered_not_mandatory,omitempty"`
	// filter for type_one_number_field_filtered field.
	TypeOneNumberFieldFiltered *FilterNumber `json:"type_one_number_field_filtered,omitempty"`
	// filter for type_one_number_field_filtered_not_mandatory field.
	TypeOneNumberFieldFilteredNotMandatory *FilterNumber `json:"type_one_number_field_filtered_not_mandatory,omitempty"`
	// filter for type_one_time_field_filtered field.
	TypeOneTimeFieldFiltered *FilterTime `json:"type_one_time_field_filtered,omitempty"`
	// filter for type_one_time_field_filtered_not_mandatory field.
	TypeOneTimeFieldFilteredNotMandatory *FilterTime `json:"type_one_time_field_filtered_not_mandatory,omitempty"`
	// filter for type_one_boolean_field_filtered field.
	TypeOneBooleanFieldFiltered *FilterBoolean `json:"type_one_boolean_field_filtered,omitempty"`
	// filter for type_one_boolean_field_filtered_not_mandatory field.
	TypeOneBooleanFieldFilteredNotMandatory *FilterBoolean `json:"type_one_boolean_field_filtered_not_mandatory,omitempty"`
	// filter for type_one_slice_with_type_twos field.
	TypeOneSliceWithTypeTwos *NestedFilterTypeTwo `json:"type_one_slice_with_type_twos,omitempty"`
}

// filter for TypeThree objects
type NestedFilterTypeThree struct {
	// logical operator for TypeThree that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterTypeThree `json:"_and,omitempty"`
	// logical operator for TypeThree that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterTypeThree `json:"_or,omitempty"`
	// logical operator for TypeThree that will reverse conditions.
	Not *NestedFilterTypeThree `json:"_not,omitempty"`
	// filter for type_three_string_field_filtered field.
	TypeThreeStringFieldFiltered *FilterString `json:"type_three_string_field_filtered,omitempty"`
	// filter for type_three_number_field_filtered field.
	TypeThreeNumberFieldFiltered *FilterNumber `json:"type_three_number_field_filtered,omitempty"`
	// filter for type_three_time_field_filtered field.
	TypeThreeTimeFieldFiltered *FilterTime `json:"type_three_time_field_filtered,omitempty"`
	// filter for type_three_boolean_field_filtered field.
	TypeThreeBooleanFieldFiltered *FilterBoolean `json:"type_three_boolean_field_filtered,omitempty"`
}

// filter for TypeTwo objects
type NestedFilterTypeTwo struct {
	// logical operator for TypeTwo that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterTypeTwo `json:"_and,omitempty"`
	// logical operator for TypeTwo that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterTypeTwo `json:"_or,omitempty"`
	// logical operator for TypeTwo that will reverse conditions.
	Not *NestedFilterTypeTwo `json:"_not,omitempty"`
	// filter for type_two_string_field_filtered field.
	TypeTwoStringFieldFiltered *FilterString `json:"type_two_string_field_filtered,omitempty"`
	// filter for type_two_number_field_filtered field.
	TypeTwoNumberFieldFiltered *FilterNumber `json:"type_two_number_field_filtered,omitempty"`
	// filter for type_two_time_field_filtered field.
	TypeTwoTimeFieldFiltered *FilterTime `json:"type_two_time_field_filtered,omitempty"`
	// filter for type_two_boolean_field_filtered field.
	TypeTwoBooleanFieldFiltered *FilterBoolean `json:"type_two_boolean_field_filtered,omitempty"`
	// filter for type_two_slice_with_type_twos field.
	TypeTwoSliceWithTypeTwos *NestedFilterTypeTwo `json:"type_two_slice_with_type_twos,omitempty"`
	// filter for type_two_with_type_three field.
	TypeTwoWithTypeThree *NestedFilterTypeThree `json:"type_two_with_type_three,omitempty"`
	// filter for type_two_with_type_three_not_mandatory field.
	TypeTwoWithTypeThreeNotMandatory *NestedFilterTypeThree `json:"type_two_with_type_three_not_mandatory,omitempty"`
}

type Query struct {
}

type TypeOne struct {
	TypeOneStringFieldFiltered              string     `json:"type_one_string_field_filtered"`
	TypeOneStringFieldFilteredNotMandatory  *string    `json:"type_one_string_field_filtered_not_mandatory,omitempty"`
	TypeOneNumberFieldFiltered              int        `json:"type_one_number_field_filtered"`
	TypeOneNumberFieldFilteredNotMandatory  *int       `json:"type_one_number_field_filtered_not_mandatory,omitempty"`
	TypeOneTimeFieldFiltered                time.Time  `json:"type_one_time_field_filtered"`
	TypeOneTimeFieldFilteredNotMandatory    *time.Time `json:"type_one_time_field_filtered_not_mandatory,omitempty"`
	TypeOneBooleanFieldFiltered             bool       `json:"type_one_boolean_field_filtered"`
	TypeOneBooleanFieldFilteredNotMandatory *bool      `json:"type_one_boolean_field_filtered_not_mandatory,omitempty"`
	TypeOneStringFieldWithNoFilter          string     `json:"type_one_string_field_with_no_filter"`
	TypeOneNumberFieldWithNoFilter          int        `json:"type_one_number_field_with_no_filter"`
	TypeOneTimeFieldWithNoFilter            time.Time  `json:"type_one_time_field_with_no_filter"`
	TypeOneSliceWithTypeTwos                []*TypeTwo `json:"type_one_slice_with_type_twos"`
}

type TypeThree struct {
	TypeThreeStringFieldFiltered     string    `json:"type_three_string_field_filtered"`
	TypeThreeNumberFieldFiltered     int       `json:"type_three_number_field_filtered"`
	TypeThreeTimeFieldFiltered       time.Time `json:"type_three_time_field_filtered"`
	TypeThreeBooleanFieldFiltered    bool      `json:"type_three_boolean_field_filtered"`
	TypeThreeStringFieldWithNoFilter string    `json:"type_three_string_field_with_no_filter"`
	TypeThreeNumberFieldWithNoFilter int       `json:"type_three_number_field_with_no_filter"`
	TypeThreeTimeFieldWithNoFilter   time.Time `json:"type_three_time_field_with_no_filter"`
}

type TypeTwo struct {
	TypeTwoStringFieldFiltered       string     `json:"type_two_string_field_filtered"`
	TypeTwoNumberFieldFiltered       int        `json:"type_two_number_field_filtered"`
	TypeTwoTimeFieldFiltered         time.Time  `json:"type_two_time_field_filtered"`
	TypeTwoBooleanFieldFiltered      bool       `json:"type_two_boolean_field_filtered"`
	TypeTwoStringFieldWithNoFilter   string     `json:"type_twoString_field_with_no_filter"`
	TypeTwoNumberFieldWithNoFilter   int        `json:"type_twoNumber_field_with_no_filter"`
	TypeTwoTimeFieldWithNoFilter     time.Time  `json:"type_twoTime_field_with_no_filter"`
	TypeTwoSliceWithTypeTwos         []*TypeTwo `json:"type_two_slice_with_type_twos"`
	TypeTwoWithTypeThree             *TypeThree `json:"type_two_with_type_three"`
	TypeTwoWithTypeThreeNotMandatory *TypeThree `json:"type_two_with_type_three_not_mandatory,omitempty"`
}

type FilterableAddons string

const (
	// Get minimum and maximum value used on all the filters for this field.
	// Useful when you need to do a range query for performance reasons.
	FilterableAddonsMinmax FilterableAddons = "MINMAX"
)

var AllFilterableAddons = []FilterableAddons{
	FilterableAddonsMinmax,
}

func (e FilterableAddons) IsValid() bool {
	switch e {
	case FilterableAddonsMinmax:
		return true
	}
	return false
}

func (e FilterableAddons) String() string {
	return string(e)
}

func (e *FilterableAddons) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterableAddons(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterableAddons", str)
	}
	return nil
}

func (e FilterableAddons) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
